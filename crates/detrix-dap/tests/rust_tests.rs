//! Rust (CodeLLDB/lldb-dap) DAP Adapter Integration Tests
//!
//! These tests verify the full DAP communication flow with lldb-dap.
//! They require lldb-dap (from LLVM/lldb) to be installed.
//!
//! Run with: cargo test --package detrix-dap --test rust_tests
//!
//! # Standard Tests (generated by macro)
//! - test_connection - Connect to running debugger
//! - test_connection_timeout - Fail gracefully on unused port
//! - test_adapter_state_transitions - Verify state machine
//! - test_adapter_stop_idempotent - Stop is idempotent
//! - test_is_ready_state - is_ready() returns correct state
//!
//! # Rust-Specific Tests
//! - test_rust_adapter_default_config - Verify default configuration
//! - test_rust_adapter_config_with_pid - Verify PID attach configuration
//! - test_rust_adapter_config_with_program - Verify program attach configuration
//! - test_rust_adapter_config_wait_for - Verify wait-for-program configuration
//! - test_rust_adapter_config_launch - Verify launch configuration
//! - test_rust_adapter_logpoint_message - Verify logpoint message format
//! - test_rust_struct_expression - Verify struct field expression
//! - test_rust_complex_expression - Verify complex expression

mod common;

use async_trait::async_trait;
use common::DapTestFixture;
use detrix_core::entities::{Location, MetricId, MetricMode, SafetyLevel};
use detrix_core::Metric;
use detrix_dap::{AdapterConfig, ConnectionMode, RustAdapter};
use detrix_testing::e2e::{require_tool, ToolDependency};
use std::process::Stdio;
use tokio::process::{Child, Command};

// ============================================================================
// Rust Test Fixture
// ============================================================================

/// Rust (lldb-dap) test fixture
pub struct RustFixture;

#[async_trait]
impl DapTestFixture for RustFixture {
    fn adapter_name() -> &'static str {
        "rust"
    }

    fn adapter_language() -> detrix_core::SourceLanguage {
        detrix_core::SourceLanguage::Rust
    }

    async fn is_available() -> bool {
        // Check for lldb-dap in common locations
        let lldb_dap_paths = [
            "lldb-dap",                            // System PATH
            "/opt/homebrew/opt/llvm/bin/lldb-dap", // Homebrew on macOS ARM
            "/usr/local/opt/llvm/bin/lldb-dap",    // Homebrew on macOS Intel
            "/usr/bin/lldb-dap",                   // Linux system install
            "/usr/lib/llvm-18/bin/lldb-dap",       // Linux LLVM 18
            "/usr/lib/llvm-17/bin/lldb-dap",       // Linux LLVM 17
            "/usr/lib/llvm-16/bin/lldb-dap",       // Linux LLVM 16
        ];

        for path in lldb_dap_paths {
            let output = Command::new(path).arg("--version").output().await;
            if let Ok(out) = output {
                if out.status.success() {
                    return true;
                }
            }
        }
        false
    }

    async fn start_debug_server(port: u16, script_path: &str) -> Result<Child, std::io::Error> {
        // Build the Rust file first
        let binary_path = format!("/tmp/detrix_rust_test_{}", port);
        let build_output = Command::new("rustc")
            .args([
                "-g", // Debug info
                "-o",
                &binary_path,
                script_path,
            ])
            .output()
            .await?;

        if !build_output.status.success() {
            eprintln!(
                "Rust build failed: {}",
                String::from_utf8_lossy(&build_output.stderr)
            );
            return Err(std::io::Error::other("Rust build failed"));
        }

        // Find lldb-dap
        let lldb_dap = find_lldb_dap().await.ok_or_else(|| {
            std::io::Error::new(std::io::ErrorKind::NotFound, "lldb-dap not found")
        })?;

        // Start lldb-dap in server mode
        // lldb-dap uses --connection for server mode
        Command::new(&lldb_dap)
            .args(["--connection", &format!("listen://127.0.0.1:{}", port)])
            .stdin(Stdio::null())
            .stdout(Stdio::inherit())
            .stderr(Stdio::inherit())
            .spawn()
    }

    fn create_adapter_config(port: u16) -> AdapterConfig {
        RustAdapter::default_config(port)
    }

    fn sample_script() -> &'static str {
        r#"use std::thread;
use std::time::Duration;

fn process_order(symbol: &str, quantity: i32, price: f64) -> f64 {
    let total = quantity as f64 * price; // Line 5 - logpoint here
    total
}

fn main() {
    println!("Rust test script started");
    for i in 0..3 {
        let result = process_order("BTCUSD", i + 1, 100.0);
        let _ = result;
        thread::sleep(Duration::from_millis(200));
    }
    println!("Rust test script finished");
    thread::sleep(Duration::from_secs(60));
}
"#
    }

    fn file_extension() -> &'static str {
        "rs"
    }

    fn logpoint_line() -> u32 {
        5
    }

    fn test_expression() -> &'static str {
        "symbol"
    }

    /// lldb-dap requires launch mode for most operations.
    /// The standard connection test doesn't work because lldb-dap in server mode
    /// requires a launch or attach request with a valid target before configurationDone.
    fn supports_standard_connection_test() -> bool {
        false
    }

    fn cleanup(script_path: &std::path::PathBuf) {
        std::fs::remove_file(script_path).ok();
        // Clean up compiled binary (extract port from script path)
        if let Some(filename) = script_path.file_name() {
            if let Some(name) = filename.to_str() {
                // Script path format: detrix_test_{port}.rs
                if let Some(port_str) = name
                    .strip_prefix("detrix_test_")
                    .and_then(|s| s.strip_suffix(".rs"))
                {
                    let binary_path = format!("/tmp/detrix_rust_test_{}", port_str);
                    std::fs::remove_file(&binary_path).ok();
                }
            }
        }
    }
}

/// Find lldb-dap in common locations
async fn find_lldb_dap() -> Option<String> {
    let lldb_dap_paths = [
        "lldb-dap",
        "/opt/homebrew/opt/llvm/bin/lldb-dap",
        "/usr/local/opt/llvm/bin/lldb-dap",
        "/usr/bin/lldb-dap",
        "/usr/lib/llvm-18/bin/lldb-dap",
        "/usr/lib/llvm-17/bin/lldb-dap",
        "/usr/lib/llvm-16/bin/lldb-dap",
    ];

    for path in lldb_dap_paths {
        let output = Command::new(path).arg("--version").output().await;
        if let Ok(out) = output {
            if out.status.success() {
                return Some(path.to_string());
            }
        }
    }
    None
}

// Generate standard tests for Rust
dap_standard_tests!(RustFixture);

// ============================================================================
// Rust-Specific Unit Tests (no lldb-dap required)
// ============================================================================

/// Test: Rust adapter PID attach configuration
#[test]
fn test_rust_adapter_config_with_pid() {
    let config = RustAdapter::config_with_pid(12345, 4711);
    assert_eq!(config.adapter_id, "rust");
    assert_eq!(config.command, "lldb-dap");

    match config.connection_mode {
        ConnectionMode::AttachPid { port, pid, .. } => {
            assert_eq!(port, 4711);
            assert_eq!(pid, Some(12345));
        }
        _ => panic!("Expected AttachPid mode"),
    }
}

/// Test: Rust adapter program attach configuration
#[test]
fn test_rust_adapter_config_with_program() {
    let config = RustAdapter::config_with_program("/path/to/binary", 4711);
    assert_eq!(config.adapter_id, "rust");

    match config.connection_mode {
        ConnectionMode::AttachPid {
            port,
            program,
            wait_for,
            ..
        } => {
            assert_eq!(port, 4711);
            assert_eq!(program, Some("/path/to/binary".to_string()));
            assert!(!wait_for); // attach_program doesn't use waitFor
        }
        _ => panic!("Expected AttachPid mode"),
    }
}

/// Test: Rust adapter wait-for-program configuration (macOS)
#[test]
fn test_rust_adapter_config_wait_for() {
    let config = RustAdapter::config_wait_for_program("/path/to/binary", 4711);
    assert_eq!(config.adapter_id, "rust");

    match config.connection_mode {
        ConnectionMode::AttachPid {
            port,
            program,
            wait_for,
            ..
        } => {
            assert_eq!(port, 4711);
            assert_eq!(program, Some("/path/to/binary".to_string()));
            assert!(wait_for); // wait_for_program uses waitFor
        }
        _ => panic!("Expected AttachPid mode"),
    }
}

/// Test: Rust adapter launch program configuration
#[test]
fn test_rust_adapter_config_launch() {
    let config = RustAdapter::config_launch_program("/path/to/binary", 4711);
    assert_eq!(config.adapter_id, "rust");

    match config.connection_mode {
        ConnectionMode::LaunchProgram { port, program, .. } => {
            assert_eq!(port, 4711);
            assert_eq!(program, "/path/to/binary");
        }
        _ => panic!("Expected LaunchProgram mode"),
    }
}

/// Test: Rust adapter launch with args configuration
#[test]
fn test_rust_adapter_config_launch_with_args() {
    let config = RustAdapter::config_launch_with_args(
        "/path/to/binary",
        vec!["--config".to_string(), "test.toml".to_string()],
        4711,
        true,
    );
    assert_eq!(config.adapter_id, "rust");

    match config.connection_mode {
        ConnectionMode::LaunchProgram {
            port,
            program,
            args,
            stop_on_entry,
            ..
        } => {
            assert_eq!(port, 4711);
            assert_eq!(program, "/path/to/binary");
            assert_eq!(args, vec!["--config", "test.toml"]);
            assert!(stop_on_entry);
        }
        _ => panic!("Expected LaunchProgram mode"),
    }
}

/// Test: Rust adapter logpoint message format
#[test]
fn test_rust_adapter_logpoint_message() {
    let metric = Metric {
        id: Some(MetricId(1)),
        name: "order_total".to_string(),
        connection_id: detrix_core::ConnectionId::from("rust-test"),
        group: None,
        location: Location {
            file: "src/main.rs".to_string(),
            line: 42,
        },
        expression: "order.total".to_string(),
        language: detrix_core::SourceLanguage::Rust,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    let message = RustAdapter::build_logpoint_message(&metric);
    assert_eq!(message, "DETRICS:order_total={order.total}");
}

/// Test: Rust struct field expression
#[test]
fn test_rust_struct_expression() {
    let metric = Metric {
        id: Some(MetricId(2)),
        name: "user_info".to_string(),
        connection_id: detrix_core::ConnectionId::from("rust-test"),
        group: None,
        location: Location {
            file: "src/handler.rs".to_string(),
            line: 100,
        },
        expression: "user.name".to_string(),
        language: detrix_core::SourceLanguage::Rust,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    let message = RustAdapter::build_logpoint_message(&metric);
    assert_eq!(message, "DETRICS:user_info={user.name}");
}

/// Test: Rust complex expression (method call)
#[test]
fn test_rust_complex_expression() {
    let metric = Metric {
        id: Some(MetricId(3)),
        name: "items_count".to_string(),
        connection_id: detrix_core::ConnectionId::from("rust-test"),
        group: None,
        location: Location {
            file: "src/service.rs".to_string(),
            line: 200,
        },
        expression: "items.len()".to_string(),
        language: detrix_core::SourceLanguage::Rust,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    let message = RustAdapter::build_logpoint_message(&metric);
    assert_eq!(message, "DETRICS:items_count={items.len()}");
}

/// Test: Rust Option expression
#[test]
fn test_rust_option_expression() {
    let metric = Metric {
        id: Some(MetricId(4)),
        name: "maybe_value".to_string(),
        connection_id: detrix_core::ConnectionId::from("rust-test"),
        group: None,
        location: Location {
            file: "src/lib.rs".to_string(),
            line: 50,
        },
        expression: "value.unwrap_or_default()".to_string(),
        language: detrix_core::SourceLanguage::Rust,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    let message = RustAdapter::build_logpoint_message(&metric);
    assert_eq!(message, "DETRICS:maybe_value={value.unwrap_or_default()}");
}

/// Test: Rust iterator chain expression
#[test]
fn test_rust_iterator_expression() {
    let metric = Metric {
        id: Some(MetricId(5)),
        name: "sum_value".to_string(),
        connection_id: detrix_core::ConnectionId::from("rust-test"),
        group: None,
        location: Location {
            file: "src/calc.rs".to_string(),
            line: 75,
        },
        expression: "values.iter().sum::<i32>()".to_string(),
        language: detrix_core::SourceLanguage::Rust,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    let message = RustAdapter::build_logpoint_message(&metric);
    assert_eq!(message, "DETRICS:sum_value={values.iter().sum::<i32>()}");
}

/// Test: Rust &str expression
#[test]
fn test_rust_str_expression() {
    let metric = Metric {
        id: Some(MetricId(6)),
        name: "greeting".to_string(),
        connection_id: detrix_core::ConnectionId::from("rust-test"),
        group: None,
        location: Location {
            file: "src/main.rs".to_string(),
            line: 10,
        },
        expression: "name.as_str()".to_string(),
        language: detrix_core::SourceLanguage::Rust,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    let message = RustAdapter::build_logpoint_message(&metric);
    assert_eq!(message, "DETRICS:greeting={name.as_str()}");
}

/// Test: Rust tuple indexing expression
#[test]
fn test_rust_tuple_expression() {
    let metric = Metric {
        id: Some(MetricId(7)),
        name: "first_elem".to_string(),
        connection_id: detrix_core::ConnectionId::from("rust-test"),
        group: None,
        location: Location {
            file: "src/lib.rs".to_string(),
            line: 30,
        },
        expression: "pair.0".to_string(),
        language: detrix_core::SourceLanguage::Rust,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    let message = RustAdapter::build_logpoint_message(&metric);
    assert_eq!(message, "DETRICS:first_elem={pair.0}");
}

/// Test: Rust array indexing expression
#[test]
fn test_rust_array_expression() {
    let metric = Metric {
        id: Some(MetricId(8)),
        name: "third_item".to_string(),
        connection_id: detrix_core::ConnectionId::from("rust-test"),
        group: None,
        location: Location {
            file: "src/data.rs".to_string(),
            line: 55,
        },
        expression: "items[2]".to_string(),
        language: detrix_core::SourceLanguage::Rust,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    let message = RustAdapter::build_logpoint_message(&metric);
    assert_eq!(message, "DETRICS:third_item={items[2]}");
}

/// Test: Rust dereference expression
#[test]
fn test_rust_deref_expression() {
    let metric = Metric {
        id: Some(MetricId(9)),
        name: "deref_value".to_string(),
        connection_id: detrix_core::ConnectionId::from("rust-test"),
        group: None,
        location: Location {
            file: "src/ptr.rs".to_string(),
            line: 20,
        },
        expression: "*ptr".to_string(),
        language: detrix_core::SourceLanguage::Rust,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    let message = RustAdapter::build_logpoint_message(&metric);
    assert_eq!(message, "DETRICS:deref_value={*ptr}");
}

/// Test: Rust reference expression
#[test]
fn test_rust_ref_expression() {
    let metric = Metric {
        id: Some(MetricId(10)),
        name: "ref_value".to_string(),
        connection_id: detrix_core::ConnectionId::from("rust-test"),
        group: None,
        location: Location {
            file: "src/borrow.rs".to_string(),
            line: 15,
        },
        expression: "&value".to_string(),
        language: detrix_core::SourceLanguage::Rust,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    let message = RustAdapter::build_logpoint_message(&metric);
    assert_eq!(message, "DETRICS:ref_value={&value}");
}

// ============================================================================
// lldb-dap Integration Tests (require lldb-dap installed)
// Run with: cargo test --test rust_tests
// ============================================================================

/// Helper: Create a Rust program that runs for a specified duration
fn rust_program_with_logpoint_line(duration_secs: u32) -> String {
    format!(
        r#"use std::thread;
use std::time::Duration;
use std::time::Instant;

fn process_order(symbol: &str, quantity: i32, price: f64) -> f64 {{
    let total = quantity as f64 * price; // Line 6 - logpoint target
    total
}}

fn main() {{
    println!("Rust test program started");
    let start = Instant::now();
    let mut i = 0;
    while start.elapsed() < Duration::from_secs({}) {{
        let result = process_order("BTCUSD", i + 1, 100.0);
        let _ = result;
        i += 1;
        thread::sleep(Duration::from_millis(100));
    }}
    println!("Rust test program finished");
}}
"#,
        duration_secs
    )
}

/// Test: lldb-dap connection and program launch
/// Verifies that adapter can connect to lldb-dap server and launch a program
/// Note: lldb-dap in server mode requires a launch request with a valid target
/// before configurationDone can succeed.
/// Run with: cargo test --test rust_tests test_lldb_full_connection
#[tokio::test]
async fn test_lldb_full_connection() {
    if !require_tool(ToolDependency::LldbDap).await {
        return;
    }

    let port = common::get_test_port();
    eprintln!("Using port {} for lldb-dap full connection test", port);

    // Create and compile a test program (lldb-dap needs a binary to debug)
    let script_path = std::env::temp_dir().join(format!("detrix_rust_test_{}.rs", port));
    let binary_path = format!("/tmp/detrix_rust_test_{}", port);
    std::fs::write(&script_path, RustFixture::sample_script()).unwrap();
    eprintln!("Created test script at {:?}", script_path);

    // Compile the Rust source to binary with debug symbols
    let build_output = Command::new("rustc")
        .args(["-g", "-o", &binary_path, script_path.to_str().unwrap()])
        .output()
        .await
        .expect("Failed to build Rust binary");

    if !build_output.status.success() {
        eprintln!(
            "Rust build failed: {}",
            String::from_utf8_lossy(&build_output.stderr)
        );
        RustFixture::cleanup(&script_path);
        panic!("Rust build failed");
    }
    eprintln!("Compiled binary at {}", binary_path);

    // Find and start lldb-dap in server mode
    let lldb_dap = find_lldb_dap().await.expect("lldb-dap not found");
    let mut lldb_process = Command::new(&lldb_dap)
        .args(["--connection", &format!("listen://127.0.0.1:{}", port)])
        .stdin(Stdio::null())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .expect("Failed to start lldb-dap");

    if !common::wait_for_port(port, 15).await {
        if let Ok(Some(status)) = lldb_process.try_wait() {
            eprintln!("lldb-dap process exited with status: {:?}", status);
        }
        lldb_process.kill().await.ok();
        RustFixture::cleanup(&script_path);
        std::fs::remove_file(&binary_path).ok();
        panic!("lldb-dap did not start listening on port {}", port);
    }
    eprintln!("lldb-dap is listening on port {}", port);

    // Use LaunchProgram mode - lldb-dap needs a program to debug
    let config = RustAdapter::config_launch_program(&binary_path, port);
    let adapter = detrix_dap::AdapterProcess::new(config);

    let result = adapter.start().await;

    adapter.stop().await.ok();
    lldb_process.kill().await.ok();
    RustFixture::cleanup(&script_path);
    std::fs::remove_file(&binary_path).ok();

    assert!(
        result.is_ok(),
        "Failed to connect to lldb-dap: {:?}",
        result
    );

    let caps = adapter.capabilities().await;
    assert!(caps.is_some(), "Should have received capabilities");
    let caps = caps.unwrap();
    assert!(
        caps.supports_log_points.unwrap_or(false),
        "lldb-dap should support logpoints"
    );

    eprintln!("lldb-dap full connection test passed!");
}

/// Test: lldb-dap program launch mode
/// Run with: cargo test --test rust_tests test_lldb_launch_mode
#[tokio::test]
async fn test_lldb_launch_mode() {
    if !require_tool(ToolDependency::LldbDap).await {
        return;
    }

    let port = common::get_test_port();
    eprintln!("Using port {} for lldb-dap launch test", port);

    // Create and compile a test program
    let script_path = std::env::temp_dir().join(format!("detrix_rust_launch_{}.rs", port));
    let binary_path = format!("/tmp/detrix_rust_launch_{}", port);
    std::fs::write(&script_path, rust_program_with_logpoint_line(3)).unwrap();

    let build_output = Command::new("rustc")
        .args(["-g", "-o", &binary_path, script_path.to_str().unwrap()])
        .output()
        .await
        .expect("Failed to build Rust binary");

    if !build_output.status.success() {
        eprintln!(
            "Rust build failed: {}",
            String::from_utf8_lossy(&build_output.stderr)
        );
        std::fs::remove_file(&script_path).ok();
        panic!("Rust build failed");
    }

    // Find lldb-dap
    let lldb_dap = find_lldb_dap().await.expect("lldb-dap not found");

    // Start lldb-dap in server mode
    let mut lldb_process = Command::new(&lldb_dap)
        .args(["--connection", &format!("listen://127.0.0.1:{}", port)])
        .stdin(Stdio::null())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .expect("Failed to start lldb-dap");

    if !common::wait_for_port(port, 15).await {
        lldb_process.kill().await.ok();
        std::fs::remove_file(&script_path).ok();
        std::fs::remove_file(&binary_path).ok();
        panic!("lldb-dap did not start listening on port {}", port);
    }
    eprintln!("lldb-dap is listening on port {}", port);

    // Create adapter with launch mode
    let config = RustAdapter::config_launch_program(&binary_path, port);
    let adapter = detrix_dap::AdapterProcess::new(config);

    let result = adapter.start().await;
    assert!(
        result.is_ok(),
        "Failed to connect to lldb-dap: {:?}",
        result
    );
    eprintln!("Adapter connected in launch mode");

    // Wait a bit and check if the program is running
    tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;

    // The program should be running
    let lldb_running = lldb_process.try_wait().ok().flatten().is_none();
    eprintln!("lldb-dap still running after 500ms: {}", lldb_running);

    // Cleanup
    adapter.stop().await.ok();
    lldb_process.kill().await.ok();
    std::fs::remove_file(&script_path).ok();
    std::fs::remove_file(&binary_path).ok();

    eprintln!("lldb-dap launch mode test passed!");
}

/// Test: lldb-dap logpoint setting via RustAdapter
/// Run with: cargo test --test rust_tests test_lldb_logpoint_setting
#[tokio::test]
#[allow(unused_imports)]
async fn test_lldb_logpoint_setting() {
    use detrix_application::DapAdapter;

    if !require_tool(ToolDependency::LldbDap).await {
        return;
    }

    let port = common::get_test_port();
    eprintln!("Using port {} for lldb-dap logpoint test", port);

    // Create and compile a test program
    let script_path = std::env::temp_dir().join(format!("detrix_rust_logpoint_{}.rs", port));
    let binary_path = format!("/tmp/detrix_rust_logpoint_{}", port);
    std::fs::write(&script_path, rust_program_with_logpoint_line(5)).unwrap();

    let build_output = Command::new("rustc")
        .args(["-g", "-o", &binary_path, script_path.to_str().unwrap()])
        .output()
        .await
        .expect("Failed to build Rust binary");

    if !build_output.status.success() {
        std::fs::remove_file(&script_path).ok();
        panic!("Rust build failed");
    }

    // Find and start lldb-dap
    let lldb_dap = find_lldb_dap().await.expect("lldb-dap not found");
    let mut lldb_process = Command::new(&lldb_dap)
        .args(["--connection", &format!("listen://127.0.0.1:{}", port)])
        .stdin(Stdio::null())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .expect("Failed to start lldb-dap");

    if !common::wait_for_port(port, 15).await {
        lldb_process.kill().await.ok();
        std::fs::remove_file(&script_path).ok();
        std::fs::remove_file(&binary_path).ok();
        panic!("lldb-dap did not start listening on port {}", port);
    }
    eprintln!("lldb-dap is listening on port {}", port);

    // Create and start RustAdapter with launch mode
    let config = RustAdapter::config_launch_program(&binary_path, port);
    let adapter = RustAdapter::new(config, std::path::PathBuf::from("/tmp"));
    let start_result = adapter.start().await;
    assert!(
        start_result.is_ok(),
        "Failed to start RustAdapter: {:?}",
        start_result
    );
    eprintln!("RustAdapter connected to lldb-dap");

    // Create a metric for the logpoint
    let metric = Metric {
        id: Some(MetricId(1)),
        name: "order_total".to_string(),
        connection_id: detrix_core::ConnectionId::from("rust-test"),
        group: None,
        location: Location {
            file: script_path.to_str().unwrap().to_string(),
            line: 6, // Line with logpoint target
        },
        expression: "total".to_string(),
        language: detrix_core::SourceLanguage::Rust,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    // Set the logpoint via DapAdapter trait
    let set_result = adapter.set_metric(&metric).await;
    eprintln!("Set metric result: {:?}", set_result);

    // Note: set_metric may fail if the file path doesn't match lldb-dap's expectations
    if let Err(ref e) = set_result {
        eprintln!(
            "Note: Logpoint setting failed (expected for path mismatch): {:?}",
            e
        );
    }

    // Wait a bit for events to be captured
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;

    // Cleanup
    adapter.stop().await.ok();
    lldb_process.kill().await.ok();
    std::fs::remove_file(&script_path).ok();
    std::fs::remove_file(&binary_path).ok();

    eprintln!("lldb-dap logpoint test completed");
}

/// Test: lldb-dap handles program exit gracefully
/// Run with: cargo test --test rust_tests test_lldb_program_exit
#[tokio::test]
async fn test_lldb_program_exit() {
    if !require_tool(ToolDependency::LldbDap).await {
        return;
    }

    let port = common::get_test_port();
    eprintln!("Using port {} for lldb-dap exit test", port);

    // Create a very short-running program (1 second)
    let script_path = std::env::temp_dir().join(format!("detrix_rust_exit_{}.rs", port));
    let binary_path = format!("/tmp/detrix_rust_exit_{}", port);
    std::fs::write(&script_path, rust_program_with_logpoint_line(1)).unwrap();

    let build_output = Command::new("rustc")
        .args(["-g", "-o", &binary_path, script_path.to_str().unwrap()])
        .output()
        .await
        .expect("Failed to build Rust binary");

    if !build_output.status.success() {
        std::fs::remove_file(&script_path).ok();
        panic!("Rust build failed");
    }

    // Find and start lldb-dap
    let lldb_dap = find_lldb_dap().await.expect("lldb-dap not found");
    let mut lldb_process = Command::new(&lldb_dap)
        .args(["--connection", &format!("listen://127.0.0.1:{}", port)])
        .stdin(Stdio::null())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .expect("Failed to start lldb-dap");

    if !common::wait_for_port(port, 15).await {
        lldb_process.kill().await.ok();
        std::fs::remove_file(&script_path).ok();
        std::fs::remove_file(&binary_path).ok();
        panic!("lldb-dap did not start listening");
    }

    // Connect adapter with launch mode
    let config = RustAdapter::config_launch_program(&binary_path, port);
    let adapter = detrix_dap::AdapterProcess::new(config);

    let result = adapter.start().await;
    assert!(
        result.is_ok(),
        "Failed to connect to lldb-dap: {:?}",
        result
    );

    // Wait for program to finish (should be about 1 second)
    tokio::time::sleep(tokio::time::Duration::from_secs(3)).await;

    // Check adapter state - should handle disconnect gracefully
    let state = adapter.state().await;
    eprintln!("Adapter state after program exit: {:?}", state);

    // Cleanup
    adapter.stop().await.ok();
    lldb_process.kill().await.ok();
    std::fs::remove_file(&script_path).ok();
    std::fs::remove_file(&binary_path).ok();

    eprintln!("lldb-dap program exit test passed!");
}

/// Test: Port conflict handling for Rust adapter
#[tokio::test]
async fn test_port_conflict_handling() {
    use tokio::net::TcpListener;

    // Bind to a port to simulate it being in use
    let listener = TcpListener::bind("127.0.0.1:0")
        .await
        .expect("Failed to bind");
    let port = listener.local_addr().unwrap().port();

    let config = RustAdapter::default_config(port);
    let adapter = detrix_dap::AdapterProcess::new(config);

    let result = adapter.start().await;

    assert!(result.is_err(), "Expected error when port is in use");

    let err = result.unwrap_err();
    let err_msg = err.to_string().to_lowercase();

    assert!(
        err_msg.contains("timeout")
            || err_msg.contains("timed out")
            || err_msg.contains("connect")
            || err_msg.contains("refused"),
        "Error should indicate connection issue: {}",
        err_msg
    );

    drop(listener);
}

/// Test: Adapter creation doesn't require debugger
#[test]
fn test_adapter_creation_no_debugger() {
    let config = RustAdapter::default_config(4711);
    let adapter = RustAdapter::new(config, std::path::PathBuf::from("/tmp"));

    // Should be able to create adapter without debugger running
    assert!(!adapter.is_ready());
}

/// Test: Location key format
#[test]
fn test_location_key_format() {
    let key = RustAdapter::location_key("src/main.rs", 42);
    assert_eq!(key, "src/main.rs#42");

    let key2 = RustAdapter::location_key("crates/detrix-core/src/lib.rs", 100);
    assert_eq!(key2, "crates/detrix-core/src/lib.rs#100");
}

/// Test: Multiple configuration modes
#[test]
fn test_multiple_config_modes() {
    // Test that all config modes produce valid configurations
    let attach = RustAdapter::default_config(4711);
    let attach_pid = RustAdapter::config_with_pid(1234, 4712);
    let attach_program = RustAdapter::config_with_program("/usr/bin/test", 4713);
    let wait_for = RustAdapter::config_wait_for_program("/usr/bin/test", 4714);
    let launch = RustAdapter::config_launch_program("/usr/bin/test", 4715);
    let launch_args = RustAdapter::config_launch_with_args(
        "/usr/bin/test",
        vec!["arg1".to_string()],
        4716,
        false,
    );

    // All should have rust adapter_id
    assert_eq!(attach.adapter_id, "rust");
    assert_eq!(attach_pid.adapter_id, "rust");
    assert_eq!(attach_program.adapter_id, "rust");
    assert_eq!(wait_for.adapter_id, "rust");
    assert_eq!(launch.adapter_id, "rust");
    assert_eq!(launch_args.adapter_id, "rust");

    // All should use lldb-dap command
    assert_eq!(attach.command, "lldb-dap");
    assert_eq!(attach_pid.command, "lldb-dap");
    assert_eq!(attach_program.command, "lldb-dap");
    assert_eq!(wait_for.command, "lldb-dap");
    assert_eq!(launch.command, "lldb-dap");
    assert_eq!(launch_args.command, "lldb-dap");
}
