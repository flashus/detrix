//! Go (Delve) DAP Adapter Integration Tests
//!
//! These tests verify the full DAP communication flow with Delve (dlv).
//! They require Go and Delve to be installed.
//!
//! Run with: cargo test --package detrix-dap --test go_tests
//!
//! # Standard Tests (generated by macro)
//! - test_connection - Connect to running debugger
//! - test_connection_timeout - Fail gracefully on unused port
//! - test_adapter_state_transitions - Verify state machine
//! - test_adapter_stop_idempotent - Stop is idempotent
//! - test_is_ready_state - is_ready() returns correct state
//!
//! # Go-Specific Tests
//! - test_go_adapter_default_config - Verify default configuration
//! - test_go_adapter_dap_server_config - Verify DAP server configuration
//! - test_go_adapter_logpoint_message - Verify logpoint message format

mod common;

use async_trait::async_trait;
use common::DapTestFixture;
use detrix_core::entities::{Location, MetricId, MetricMode, SafetyLevel};
use detrix_core::Metric;
use detrix_dap::{AdapterConfig, GoAdapter};
use detrix_testing::e2e::{require_tool, ToolDependency};
use std::process::Stdio;
use tokio::process::{Child, Command};

// ============================================================================
// Go Test Fixture
// ============================================================================

/// Go (Delve) test fixture
pub struct GoFixture;

#[async_trait]
impl DapTestFixture for GoFixture {
    fn adapter_name() -> &'static str {
        "go"
    }

    fn adapter_language() -> detrix_core::SourceLanguage {
        detrix_core::SourceLanguage::Go
    }

    async fn is_available() -> bool {
        let output = Command::new("dlv").args(["version"]).output().await;

        match output {
            Ok(out) => out.status.success(),
            Err(_) => false,
        }
    }

    async fn start_debug_server(port: u16, script_path: &str) -> Result<Child, std::io::Error> {
        // Build the Go file first
        let binary_path = format!("/tmp/detrix_go_test_{}", port);
        let build_output = Command::new("go")
            .args([
                "build",
                "-gcflags",
                "all=-N -l",
                "-o",
                &binary_path,
                script_path,
            ])
            .output()
            .await?;

        if !build_output.status.success() {
            eprintln!(
                "Go build failed: {}",
                String::from_utf8_lossy(&build_output.stderr)
            );
            return Err(std::io::Error::other("Go build failed"));
        }

        // Start Delve in debug mode with DAP protocol
        // This starts both the DAP server AND the debug session
        Command::new("dlv")
            .args([
                "exec",
                &binary_path,
                "--headless",
                "--api-version=2",
                "--accept-multiclient",
                "--listen",
                &format!("127.0.0.1:{}", port),
            ])
            .stdin(Stdio::null())
            .stdout(Stdio::inherit())
            .stderr(Stdio::inherit())
            .spawn()
    }

    fn create_adapter_config(port: u16) -> AdapterConfig {
        GoAdapter::default_config(port)
    }

    fn sample_script() -> &'static str {
        r#"package main

import (
    "fmt"
    "time"
)

func processOrder(symbol string, quantity int, price float64) float64 {
    total := float64(quantity) * price // Line 10 - logpoint here
    return total
}

func main() {
    fmt.Println("Go test script started")
    for i := 0; i < 3; i++ {
        result := processOrder("BTCUSD", i+1, 100.0)
        _ = result
        time.Sleep(200 * time.Millisecond)
    }
    fmt.Println("Go test script finished")
    time.Sleep(60 * time.Second)
}
"#
    }

    fn file_extension() -> &'static str {
        "go"
    }

    fn logpoint_line() -> u32 {
        10
    }

    fn test_expression() -> &'static str {
        "symbol"
    }

    /// Delve headless mode uses "attach remote" DAP request.
    /// Now implemented in AdapterProcess, so standard tests should work.
    fn supports_standard_connection_test() -> bool {
        true
    }

    fn cleanup(script_path: &std::path::PathBuf) {
        std::fs::remove_file(script_path).ok();
        // Clean up compiled binary (extract port from script path)
        if let Some(filename) = script_path.file_name() {
            if let Some(name) = filename.to_str() {
                // Script path format: detrix_test_{port}.go
                if let Some(port_str) = name
                    .strip_prefix("detrix_test_")
                    .and_then(|s| s.strip_suffix(".go"))
                {
                    let binary_path = format!("/tmp/detrix_go_test_{}", port_str);
                    std::fs::remove_file(&binary_path).ok();
                }
            }
        }
    }
}

// Generate standard tests for Go
dap_standard_tests!(GoFixture);

// ============================================================================
// Go-Specific Tests
// ============================================================================

/// Test: Go adapter DAP server configuration
#[test]
fn test_go_adapter_dap_server_config() {
    let config = GoAdapter::dap_server_config("127.0.0.1", 38697);
    assert_eq!(config.adapter_id, "go");
    assert_eq!(config.command, "dlv");
    assert!(config.args.contains(&"dap".to_string()));
    assert!(config.args.contains(&"--listen".to_string()));
}

/// Test: Go adapter logpoint message format
#[test]
fn test_go_adapter_logpoint_message() {
    let metric = Metric {
        id: Some(MetricId(1)),
        name: "order_total".to_string(),
        connection_id: detrix_core::ConnectionId::from("go-test"),
        group: None,
        location: Location {
            file: "main.go".to_string(),
            line: 29,
        },
        expressions: vec!["order.Symbol".to_string()],
        language: detrix_core::SourceLanguage::Go,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    let message = GoAdapter::build_logpoint_message(&metric);
    assert_eq!(message, "DETRICS:order_total={order.Symbol}");
}

/// Test: Go struct field expression
#[test]
fn test_go_struct_expression() {
    let metric = Metric {
        id: Some(MetricId(2)),
        name: "user_info".to_string(),
        connection_id: detrix_core::ConnectionId::from("go-test"),
        group: None,
        location: Location {
            file: "handler.go".to_string(),
            line: 42,
        },
        expressions: vec!["user.Name".to_string()],
        language: detrix_core::SourceLanguage::Go,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    let message = GoAdapter::build_logpoint_message(&metric);
    assert_eq!(message, "DETRICS:user_info={user.Name}");
}

/// Test: Go slice/map expression
#[test]
fn test_go_complex_expression() {
    let metric = Metric {
        id: Some(MetricId(3)),
        name: "items_count".to_string(),
        connection_id: detrix_core::ConnectionId::from("go-test"),
        group: None,
        location: Location {
            file: "service.go".to_string(),
            line: 100,
        },
        expressions: vec!["len(items)".to_string()],
        language: detrix_core::SourceLanguage::Go,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    let message = GoAdapter::build_logpoint_message(&metric);
    assert_eq!(message, "DETRICS:items_count={len(items)}");
}

// ============================================================================
// Delve Integration Tests (require dlv installed)
// Run with: cargo test --test go_tests
// ============================================================================

/// Helper: Create a Go program that runs for a specified duration
fn go_program_with_logpoint_line(duration_secs: u32) -> String {
    format!(
        r#"package main

import (
    "fmt"
    "time"
)

func processOrder(symbol string, quantity int, price float64) float64 {{
    total := float64(quantity) * price // Line 10 - logpoint target
    return total
}}

func main() {{
    fmt.Println("Go test program started")
    start := time.Now()
    i := 0
    for time.Since(start) < time.Duration({}) * time.Second {{
        result := processOrder("BTCUSD", i+1, 100.0)
        _ = result
        i++
        time.Sleep(100 * time.Millisecond)
    }}
    fmt.Println("Go test program finished")
}}
"#,
        duration_secs
    )
}

/// Test: Delve DAP connection and program continuation
/// Verifies that after attach, the program continues execution
/// Run with: cargo test --test go_tests test_delve_full_connection
#[tokio::test]
async fn test_delve_full_connection() {
    if !require_tool(ToolDependency::Delve).await {
        return;
    }

    let port = common::get_test_port();
    eprintln!("Using port {} for Delve full connection test", port);

    let script_path = std::env::temp_dir().join(format!("detrix_go_test_{}.go", port));
    std::fs::write(&script_path, GoFixture::sample_script()).unwrap();
    eprintln!("Created test script at {:?}", script_path);

    let mut delve_process =
        match GoFixture::start_debug_server(port, script_path.to_str().unwrap()).await {
            Ok(p) => p,
            Err(e) => {
                eprintln!("Failed to start Delve: {:?}", e);
                GoFixture::cleanup(&script_path);
                return;
            }
        };

    if !common::wait_for_port(port, 15).await {
        if let Ok(Some(status)) = delve_process.try_wait() {
            eprintln!("Delve process exited with status: {:?}", status);
        }
        delve_process.kill().await.ok();
        GoFixture::cleanup(&script_path);
        panic!("Delve did not start listening on port {}", port);
    }
    eprintln!("Delve is listening on port {}", port);

    let config = GoAdapter::default_config(port);
    let adapter = detrix_dap::AdapterProcess::new(config);

    let result = adapter.start().await;

    adapter.stop().await.ok();
    delve_process.kill().await.ok();
    GoFixture::cleanup(&script_path);

    assert!(result.is_ok(), "Failed to connect to Delve: {:?}", result);

    let caps = adapter.capabilities().await;
    assert!(caps.is_some(), "Should have received capabilities");
    let caps = caps.unwrap();
    assert!(
        caps.supports_log_points.unwrap_or(false),
        "Delve should support logpoints"
    );

    eprintln!("Delve full connection test passed!");
}

/// Test: Delve program continues execution after attach
/// This verifies the continue request is sent after configurationDone
/// Run with: cargo test --test go_tests test_delve_program_continues
#[tokio::test]
async fn test_delve_program_continues() {
    if !require_tool(ToolDependency::Delve).await {
        return;
    }

    let port = common::get_test_port();
    eprintln!("Using port {} for Delve continuation test", port);

    // Use a short-running program (3 seconds)
    let script_path = std::env::temp_dir().join(format!("detrix_go_cont_{}.go", port));
    std::fs::write(&script_path, go_program_with_logpoint_line(3)).unwrap();
    eprintln!("Created test script at {:?}", script_path);

    // Build the Go binary
    let binary_path = format!("/tmp/detrix_go_cont_{}", port);
    let build_output = Command::new("go")
        .args([
            "build",
            "-gcflags",
            "all=-N -l",
            "-o",
            &binary_path,
            script_path.to_str().unwrap(),
        ])
        .output()
        .await
        .expect("Failed to build Go binary");

    if !build_output.status.success() {
        eprintln!(
            "Go build failed: {}",
            String::from_utf8_lossy(&build_output.stderr)
        );
        std::fs::remove_file(&script_path).ok();
        panic!("Go build failed");
    }

    // Start Delve in headless mode
    let mut delve_process = Command::new("dlv")
        .args([
            "exec",
            &binary_path,
            "--headless",
            "--api-version=2",
            "--accept-multiclient",
            "--listen",
            &format!("127.0.0.1:{}", port),
        ])
        .stdin(Stdio::null())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .expect("Failed to start Delve");

    // Wait for Delve to start listening
    if !common::wait_for_port(port, 15).await {
        delve_process.kill().await.ok();
        std::fs::remove_file(&script_path).ok();
        std::fs::remove_file(&binary_path).ok();
        panic!("Delve did not start listening on port {}", port);
    }
    eprintln!("Delve is listening on port {}", port);

    // Connect adapter (this should send continue request)
    let config = GoAdapter::default_config(port);
    let adapter = detrix_dap::AdapterProcess::new(config);

    let result = adapter.start().await;
    assert!(result.is_ok(), "Failed to connect to Delve: {:?}", result);
    eprintln!("Adapter connected, program should be running now");

    // Wait a bit and check if Delve process is still running (program executing)
    tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;

    // The program should be running - we can verify by checking if delve is still active
    let delve_running = delve_process.try_wait().ok().flatten().is_none();
    eprintln!("Delve still running after 500ms: {}", delve_running);

    // Wait for program to finish (3 seconds max)
    tokio::time::sleep(tokio::time::Duration::from_secs(4)).await;

    // Cleanup
    adapter.stop().await.ok();
    delve_process.kill().await.ok();
    std::fs::remove_file(&script_path).ok();
    std::fs::remove_file(&binary_path).ok();

    assert!(
        delve_running,
        "Delve should have been running after adapter connect (program should have continued)"
    );
    eprintln!("Delve program continuation test passed!");
}

/// Test: Delve logpoint setting via GoAdapter
/// Run with: cargo test --test go_tests test_delve_logpoint_setting
#[tokio::test]
#[allow(unused_imports)]
async fn test_delve_logpoint_setting() {
    use detrix_application::DapAdapter;

    if !require_tool(ToolDependency::Delve).await {
        return;
    }

    let port = common::get_test_port();
    eprintln!("Using port {} for Delve logpoint test", port);

    // Use a program that runs for 5 seconds
    let script_path = std::env::temp_dir().join(format!("detrix_go_logpoint_{}.go", port));
    std::fs::write(&script_path, go_program_with_logpoint_line(5)).unwrap();
    eprintln!("Created test script at {:?}", script_path);

    // Build the Go binary
    let binary_path = format!("/tmp/detrix_go_logpoint_{}", port);
    let build_output = Command::new("go")
        .args([
            "build",
            "-gcflags",
            "all=-N -l",
            "-o",
            &binary_path,
            script_path.to_str().unwrap(),
        ])
        .output()
        .await
        .expect("Failed to build Go binary");

    if !build_output.status.success() {
        eprintln!(
            "Go build failed: {}",
            String::from_utf8_lossy(&build_output.stderr)
        );
        std::fs::remove_file(&script_path).ok();
        panic!("Go build failed");
    }

    // Start Delve in headless mode
    let mut delve_process = Command::new("dlv")
        .args([
            "exec",
            &binary_path,
            "--headless",
            "--api-version=2",
            "--accept-multiclient",
            "--listen",
            &format!("127.0.0.1:{}", port),
        ])
        .stdin(Stdio::null())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .expect("Failed to start Delve");

    // Wait for Delve to start listening
    if !common::wait_for_port(port, 15).await {
        delve_process.kill().await.ok();
        std::fs::remove_file(&script_path).ok();
        std::fs::remove_file(&binary_path).ok();
        panic!("Delve did not start listening on port {}", port);
    }
    eprintln!("Delve is listening on port {}", port);

    // Create and start GoAdapter
    let config = GoAdapter::default_config(port);
    let adapter = GoAdapter::new(config, std::path::PathBuf::from("/tmp"));
    let start_result = adapter.start().await;
    assert!(
        start_result.is_ok(),
        "Failed to start GoAdapter: {:?}",
        start_result
    );
    eprintln!("GoAdapter connected to Delve");

    // Create a metric for the logpoint
    let metric = Metric {
        id: Some(MetricId(1)),
        name: "order_total".to_string(),
        connection_id: detrix_core::ConnectionId::from("go-test"),
        group: None,
        location: Location {
            file: script_path.to_str().unwrap().to_string(),
            line: 10, // Line with logpoint target
        },
        expressions: vec!["total".to_string()],
        language: detrix_core::SourceLanguage::Go,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    // Set the logpoint via DapAdapter trait
    let set_result = adapter.set_metric(&metric).await;
    eprintln!("Set metric result: {:?}", set_result);

    // Note: set_metric may fail if the file path doesn't match Delve's expectations
    // This is expected behavior - Delve requires exact source paths
    if let Err(ref e) = set_result {
        eprintln!(
            "Note: Logpoint setting failed (expected for path mismatch): {:?}",
            e
        );
    }

    // Wait a bit for events to be captured
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;

    // Cleanup
    adapter.stop().await.ok();
    delve_process.kill().await.ok();
    std::fs::remove_file(&script_path).ok();
    std::fs::remove_file(&binary_path).ok();

    // The important thing is that the adapter connected and the initialization flow worked
    eprintln!("Delve logpoint test completed");
}

/// Test: Delve handles program exit gracefully
/// Run with: cargo test --test go_tests test_delve_program_exit
#[tokio::test]
async fn test_delve_program_exit() {
    if !require_tool(ToolDependency::Delve).await {
        return;
    }

    let port = common::get_test_port();
    eprintln!("Using port {} for Delve exit test", port);

    // Use a very short program (1 second)
    let script_path = std::env::temp_dir().join(format!("detrix_go_exit_{}.go", port));
    std::fs::write(&script_path, go_program_with_logpoint_line(1)).unwrap();

    // Build the Go binary
    let binary_path = format!("/tmp/detrix_go_exit_{}", port);
    let build_output = Command::new("go")
        .args([
            "build",
            "-gcflags",
            "all=-N -l",
            "-o",
            &binary_path,
            script_path.to_str().unwrap(),
        ])
        .output()
        .await
        .expect("Failed to build Go binary");

    if !build_output.status.success() {
        std::fs::remove_file(&script_path).ok();
        panic!("Go build failed");
    }

    // Start Delve
    let mut delve_process = Command::new("dlv")
        .args([
            "exec",
            &binary_path,
            "--headless",
            "--api-version=2",
            "--accept-multiclient",
            "--listen",
            &format!("127.0.0.1:{}", port),
        ])
        .stdin(Stdio::null())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .expect("Failed to start Delve");

    if !common::wait_for_port(port, 15).await {
        delve_process.kill().await.ok();
        std::fs::remove_file(&script_path).ok();
        std::fs::remove_file(&binary_path).ok();
        panic!("Delve did not start listening");
    }

    // Connect adapter
    let config = GoAdapter::default_config(port);
    let adapter = detrix_dap::AdapterProcess::new(config);

    let result = adapter.start().await;
    assert!(result.is_ok(), "Failed to connect to Delve: {:?}", result);

    // Wait for program to finish (should be about 1 second)
    tokio::time::sleep(tokio::time::Duration::from_secs(3)).await;

    // Check adapter state - should handle disconnect gracefully
    let state = adapter.state().await;
    eprintln!("Adapter state after program exit: {:?}", state);

    // Cleanup
    adapter.stop().await.ok();
    delve_process.kill().await.ok();
    std::fs::remove_file(&script_path).ok();
    std::fs::remove_file(&binary_path).ok();

    eprintln!("Delve program exit test passed!");
}
