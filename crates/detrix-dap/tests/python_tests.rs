//! Python (debugpy) DAP Adapter Integration Tests
//!
//! These tests verify the full DAP communication flow with debugpy.
//! They require Python and debugpy to be installed.
//!
//! Run with: cargo test --package detrix-dap --test python_tests
//!
//! # Standard Tests (generated by macro)
//! - test_connection - Connect to running debugger
//! - test_connection_timeout - Fail gracefully on unused port
//! - test_adapter_state_transitions - Verify state machine
//! - test_adapter_stop_idempotent - Stop is idempotent
//! - test_is_ready_state - is_ready() returns correct state
//!
//! # Python-Specific Tests
//! - test_debugpy_logpoint_setting - Set logpoints with Python expressions
//! - test_debugpy_metric_event_reception - Receive metric events
//! - test_debugpy_reconnection - Handle adapter stop/start
//! - test_reconnection_after_debugpy_restart - Connect after debugpy restart

mod common;

use async_trait::async_trait;
use common::DapTestFixture;
use detrix_core::entities::{Location, MetricId, MetricMode, SafetyLevel};
use detrix_core::Metric;
use detrix_dap::{AdapterConfig, AdapterProcess, AdapterState, PythonAdapter};
use detrix_ports::DapAdapter;
use detrix_testing::e2e::{require_tool, ToolDependency};
use std::process::Stdio;
use std::time::Duration;
use tokio::process::{Child, Command};
use tokio::time::timeout;

// ============================================================================
// Python Test Fixture
// ============================================================================

/// Python (debugpy) test fixture
pub struct PythonFixture;

#[async_trait]
impl DapTestFixture for PythonFixture {
    fn adapter_name() -> &'static str {
        "python"
    }

    fn adapter_language() -> detrix_core::SourceLanguage {
        detrix_core::SourceLanguage::Python
    }

    async fn is_available() -> bool {
        let output = Command::new("python")
            .args(["-c", "import debugpy; print(debugpy.__version__)"])
            .output()
            .await;

        match output {
            Ok(out) => out.status.success(),
            Err(_) => false,
        }
    }

    async fn start_debug_server(port: u16, script_path: &str) -> Result<Child, std::io::Error> {
        Command::new("python")
            .args([
                "-m",
                "debugpy",
                "--listen",
                &format!("{}", port),
                "--wait-for-client",
                script_path,
            ])
            .stdin(Stdio::null())
            .stdout(Stdio::inherit())
            .stderr(Stdio::inherit())
            .spawn()
    }

    fn create_adapter_config(port: u16) -> AdapterConfig {
        PythonAdapter::default_config(port)
    }

    fn sample_script() -> &'static str {
        r#"import time

def process_order(symbol, quantity, price):
    total = quantity * price  # Line 4 - logpoint here
    return total

for i in range(3):
    result = process_order("BTCUSD", i + 1, 100.0)
    time.sleep(0.2)

print("Done")
"#
    }

    fn file_extension() -> &'static str {
        "py"
    }

    fn logpoint_line() -> u32 {
        4
    }

    fn test_expression() -> &'static str {
        "f'symbol={symbol}, qty={quantity}'"
    }
}

// Generate standard tests for Python
dap_standard_tests!(PythonFixture);

// ============================================================================
// Python-Specific Tests
// ============================================================================

/// Helper to start a debugpy server
async fn start_debugpy_server(port: u16, script_path: &str) -> Result<Child, std::io::Error> {
    PythonFixture::start_debug_server(port, script_path).await
}

/// Test: Setting logpoints with Python expressions
#[tokio::test]
async fn test_debugpy_logpoint_setting() {
    if !require_tool(ToolDependency::Debugpy).await {
        return;
    }

    let port = common::get_test_port();

    let script_content = PythonFixture::sample_script();
    let script_path = std::env::temp_dir().join("detrix_logpoint_test.py");
    std::fs::write(&script_path, script_content).unwrap();

    let mut debugpy_process = start_debugpy_server(port, script_path.to_str().unwrap())
        .await
        .expect("Failed to start debugpy");

    assert!(
        common::wait_for_port(port, 5).await,
        "debugpy did not start listening"
    );

    let config = PythonAdapter::default_config(port);
    let python_adapter = PythonAdapter::new(config, std::env::temp_dir());

    python_adapter
        .start()
        .await
        .expect("Failed to start adapter");

    let metric = Metric {
        id: Some(MetricId(1)),
        name: "order_total".to_string(),
        connection_id: detrix_core::ConnectionId::from("default"),
        group: None,
        location: Location {
            file: "detrix_logpoint_test.py".to_string(),
            line: 4,
        },
        expression: "f'symbol={symbol}, qty={quantity}'".to_string(),
        language: detrix_core::SourceLanguage::Python,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    let result = python_adapter.set_metric(&metric).await;
    assert!(result.is_ok(), "Failed to set logpoint: {:?}", result);

    let set_result = result.unwrap();
    eprintln!(
        "Logpoint result: verified={}, line={}, message={:?}",
        set_result.verified, set_result.line, set_result.message
    );

    assert!(
        set_result.verified,
        "Breakpoint should be verified by debugpy"
    );
    assert_eq!(set_result.line, 4, "Breakpoint should be on line 4");

    python_adapter.stop().await.ok();
    debugpy_process.kill().await.ok();
    std::fs::remove_file(&script_path).ok();
}

/// Test: Receiving metric events from debugpy
#[tokio::test]
async fn test_debugpy_metric_event_reception() {
    if !require_tool(ToolDependency::Debugpy).await {
        return;
    }

    let port = common::get_test_port();

    let script_content = r#"import time

def process_order(symbol, quantity, price):
    total = quantity * price  # Line 4 - logpoint here
    return total

# Call the function 3 times with different values
process_order("BTCUSD", 10, 100.0)
time.sleep(0.1)
process_order("ETHUSD", 5, 200.0)
time.sleep(0.1)
process_order("SOLUSD", 20, 50.0)
time.sleep(0.5)
print("Done")
"#;

    let script_path = std::env::temp_dir().join("detrix_event_test.py");
    std::fs::write(&script_path, script_content).unwrap();

    let mut debugpy_process = start_debugpy_server(port, script_path.to_str().unwrap())
        .await
        .expect("Failed to start debugpy");

    assert!(
        common::wait_for_port(port, 5).await,
        "debugpy did not start listening"
    );

    let config = PythonAdapter::default_config(port);
    let python_adapter = PythonAdapter::new(config, std::env::temp_dir());

    python_adapter
        .start()
        .await
        .expect("Failed to start adapter");

    let mut event_rx = python_adapter
        .subscribe_events()
        .await
        .expect("Failed to subscribe to events");

    let metric = Metric {
        id: Some(MetricId(1)),
        name: "order_info".to_string(),
        connection_id: detrix_core::ConnectionId::from("default"),
        group: None,
        location: Location {
            file: "detrix_event_test.py".to_string(),
            line: 4,
        },
        expression: "f'symbol={symbol}, qty={quantity}, price={price}'".to_string(),
        language: detrix_core::SourceLanguage::Python,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    let set_result = python_adapter
        .set_metric(&metric)
        .await
        .expect("Failed to set logpoint");
    assert!(set_result.verified, "Breakpoint should be verified");
    eprintln!("Logpoint set on line {}", set_result.line);

    // Collect events
    let mut received_events = Vec::new();
    let collect_timeout = Duration::from_secs(5);
    let start = std::time::Instant::now();

    while start.elapsed() < collect_timeout && received_events.len() < 3 {
        match timeout(Duration::from_millis(500), event_rx.recv()).await {
            Ok(Some(event)) => {
                eprintln!("Received event: {:?}", event.value_string);
                received_events.push(event);
            }
            Ok(None) => {
                eprintln!("Event channel closed");
                break;
            }
            Err(_) => {
                // Timeout on recv, continue waiting
            }
        }
    }

    python_adapter.stop().await.ok();
    debugpy_process.kill().await.ok();
    std::fs::remove_file(&script_path).ok();

    eprintln!("Received {} events", received_events.len());
    assert!(
        !received_events.is_empty(),
        "Should have received at least one metric event"
    );

    for event in &received_events {
        assert!(
            event.value_string.is_some(),
            "Event should have value_string"
        );
        let value = event.value_string.as_ref().unwrap();
        eprintln!("Event value: {}", value);

        assert!(value.contains("symbol="), "Value should contain symbol");
        assert!(value.contains("qty="), "Value should contain qty");
        assert!(value.contains("price="), "Value should contain price");
        assert_eq!(event.metric_id, MetricId(1), "Metric ID should match");
        assert!(event.timestamp > 0, "Timestamp should be set");
    }

    eprintln!(
        "Test passed! Received {} valid metric events",
        received_events.len()
    );
}

/// Test: Adapter stop/start cycle
#[tokio::test]
async fn test_debugpy_reconnection() {
    if !require_tool(ToolDependency::Debugpy).await {
        return;
    }

    let port = common::get_test_port();

    let script_content = r#"
import time
time.sleep(10)
"#;

    let script_path = std::env::temp_dir().join("detrix_reconnect_test.py");
    std::fs::write(&script_path, script_content).unwrap();

    let mut debugpy_process = start_debugpy_server(port, script_path.to_str().unwrap())
        .await
        .expect("Failed to start debugpy");

    assert!(
        common::wait_for_port(port, 5).await,
        "debugpy did not start listening"
    );

    let config = PythonAdapter::default_config(port);
    let adapter = AdapterProcess::new(config);

    adapter.start().await.expect("First connection failed");
    assert_eq!(adapter.state().await, AdapterState::Ready);

    adapter.stop().await.expect("Stop failed");
    assert_eq!(adapter.state().await, AdapterState::Stopped);

    debugpy_process.kill().await.ok();
    std::fs::remove_file(&script_path).ok();
}

/// Test: Reconnection after debugpy restart
#[tokio::test]
async fn test_reconnection_after_debugpy_restart() {
    if !require_tool(ToolDependency::Debugpy).await {
        return;
    }

    let port = common::get_test_port();

    let script_content = r#"
import time
while True:
    time.sleep(1)
"#;

    let script_path = std::env::temp_dir().join("detrix_restart_test.py");
    std::fs::write(&script_path, script_content).unwrap();

    // Start first debugpy instance
    let mut debugpy1 = start_debugpy_server(port, script_path.to_str().unwrap())
        .await
        .expect("Failed to start first debugpy");

    assert!(
        common::wait_for_port(port, 5).await,
        "First debugpy did not start listening"
    );

    // Connect first adapter
    let config1 = PythonAdapter::default_config(port);
    let adapter1 = AdapterProcess::new(config1);

    adapter1.start().await.expect("First connection failed");
    assert_eq!(adapter1.state().await, AdapterState::Ready);
    assert!(adapter1.is_ready(), "Adapter should report ready");

    // Stop adapter BEFORE killing debugpy
    adapter1.stop().await.ok();
    assert_eq!(adapter1.state().await, AdapterState::Stopped);
    drop(adapter1);

    // Kill debugpy
    debugpy1.kill().await.ok();
    tokio::time::sleep(Duration::from_millis(1000)).await;

    // Start new debugpy instance
    let mut debugpy2 = start_debugpy_server(port, script_path.to_str().unwrap())
        .await
        .expect("Failed to start second debugpy");

    assert!(
        common::wait_for_port(port, 10).await,
        "Second debugpy did not start listening"
    );

    // Connect new adapter
    let config2 = PythonAdapter::default_config(port);
    let adapter2 = AdapterProcess::new(config2);

    adapter2
        .start()
        .await
        .expect("Connection to restarted debugpy failed");
    assert_eq!(adapter2.state().await, AdapterState::Ready);
    assert!(adapter2.is_ready(), "Second adapter should report ready");

    adapter2.stop().await.ok();
    debugpy2.kill().await.ok();
    std::fs::remove_file(&script_path).ok();
}

/// Test: Python f-string expression evaluation
/// This is a Python-specific test for f-string syntax
#[tokio::test]
async fn test_python_fstring_expression() {
    if !require_tool(ToolDependency::Debugpy).await {
        return;
    }

    let port = common::get_test_port();

    // Script with various Python types
    let script_content = r#"import time

def process_data(name, count, value):
    result = {"name": name, "count": count, "value": value}
    return result

process_data("test", 42, 3.14)
time.sleep(60)
"#;

    let script_path = std::env::temp_dir().join("detrix_fstring_test.py");
    std::fs::write(&script_path, script_content).unwrap();

    let mut debugpy_process = start_debugpy_server(port, script_path.to_str().unwrap())
        .await
        .expect("Failed to start debugpy");

    assert!(
        common::wait_for_port(port, 5).await,
        "debugpy did not start listening"
    );

    let config = PythonAdapter::default_config(port);
    let python_adapter = PythonAdapter::new(config, std::env::temp_dir());

    python_adapter
        .start()
        .await
        .expect("Failed to start adapter");

    // Test complex f-string expression
    let metric = Metric {
        id: Some(MetricId(1)),
        name: "fstring_test".to_string(),
        connection_id: detrix_core::ConnectionId::from("default"),
        group: None,
        location: Location {
            file: "detrix_fstring_test.py".to_string(),
            line: 4,
        },
        expression: "f'name={name!r}, count={count:03d}, value={value:.2f}'".to_string(),
        language: detrix_core::SourceLanguage::Python,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    let result = python_adapter.set_metric(&metric).await;
    assert!(
        result.is_ok(),
        "Failed to set logpoint with f-string: {:?}",
        result
    );

    let set_result = result.unwrap();
    assert!(
        set_result.verified,
        "Complex f-string breakpoint should be verified"
    );

    python_adapter.stop().await.ok();
    debugpy_process.kill().await.ok();
    std::fs::remove_file(&script_path).ok();
}

/// Test: Port conflict handling
#[tokio::test]
async fn test_port_conflict_handling() {
    use tokio::net::TcpListener;

    // Bind to a port to simulate it being in use
    let listener = TcpListener::bind("127.0.0.1:0")
        .await
        .expect("Failed to bind");
    let port = listener.local_addr().unwrap().port();

    let config = PythonAdapter::default_config(port);
    let adapter = AdapterProcess::new(config);

    let result = adapter.start().await;

    assert!(result.is_err(), "Expected error when port is in use");

    let err = result.unwrap_err();
    let err_msg = err.to_string().to_lowercase();

    assert!(
        err_msg.contains("timeout")
            || err_msg.contains("timed out")
            || err_msg.contains("connect")
            || err_msg.contains("refused"),
        "Error should indicate connection issue: {}",
        err_msg
    );

    drop(listener);
}

/// Test: Multiple breakpoints on same file (race condition fix test)
///
/// This test verifies that when two metrics are added sequentially to the same file,
/// BOTH metrics receive events. This was a critical bug where DAP's `setBreakpoints`
/// command replaces ALL breakpoints in a file, so adding metrics one-by-one would
/// cause earlier metrics' breakpoints to be removed.
///
/// The fix ensures that `set_metric()` sends ALL active breakpoints for a file
/// in a single `setBreakpoints` call.
#[tokio::test]
async fn test_multiple_breakpoints_same_file() {
    if !require_tool(ToolDependency::Debugpy).await {
        return;
    }

    let port = common::get_test_port();

    // Script with two functions that we'll set breakpoints on
    // Both functions are called multiple times
    let script_content = r#"import time

def place_order(symbol, quantity):
    order_id = f"{symbol}_{quantity}"  # Line 4 - metric for symbol (string)
    return order_id

def update_position(size, price):
    total = size * price  # Line 8 - metric for size (integer)
    return total

# Call both functions alternately
for i in range(5):
    order = place_order("BTCUSD" if i % 2 == 0 else "ETHUSD", i + 1)
    position = update_position(i * 10, 100.0)
    time.sleep(0.3)

print("Done")
"#;

    let script_path = std::env::temp_dir().join("detrix_multiple_bp_test.py");
    std::fs::write(&script_path, script_content).unwrap();

    let mut debugpy_process = start_debugpy_server(port, script_path.to_str().unwrap())
        .await
        .expect("Failed to start debugpy");

    assert!(
        common::wait_for_port(port, 5).await,
        "debugpy did not start listening"
    );

    let config = PythonAdapter::default_config(port);
    let python_adapter = PythonAdapter::new(config, std::env::temp_dir());

    python_adapter
        .start()
        .await
        .expect("Failed to start adapter");

    let mut event_rx = python_adapter
        .subscribe_events()
        .await
        .expect("Failed to subscribe to events");

    // Set FIRST metric (symbol - string type)
    let metric1 = Metric {
        id: Some(MetricId(1)),
        name: "order_symbol".to_string(),
        connection_id: detrix_core::ConnectionId::from("default"),
        group: None,
        location: Location {
            file: "detrix_multiple_bp_test.py".to_string(),
            line: 4,
        },
        expression: "symbol".to_string(), // String type
        language: detrix_core::SourceLanguage::Python,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    let result1 = python_adapter.set_metric(&metric1).await;
    assert!(result1.is_ok(), "Failed to set first metric: {:?}", result1);
    let set_result1 = result1.unwrap();
    assert!(set_result1.verified, "First breakpoint should be verified");
    eprintln!(
        "First metric set on line {}: verified={}",
        set_result1.line, set_result1.verified
    );

    // Set SECOND metric (size - integer type) - this used to overwrite the first!
    let metric2 = Metric {
        id: Some(MetricId(2)),
        name: "position_size".to_string(),
        connection_id: detrix_core::ConnectionId::from("default"),
        group: None,
        location: Location {
            file: "detrix_multiple_bp_test.py".to_string(),
            line: 8,
        },
        expression: "size".to_string(), // Integer type
        language: detrix_core::SourceLanguage::Python,
        enabled: true,
        mode: MetricMode::Stream,
        condition: None,
        safety_level: SafetyLevel::Strict,
        created_at: None,
        capture_stack_trace: false,
        stack_trace_ttl: None,
        stack_trace_slice: None,
        capture_memory_snapshot: false,
        snapshot_scope: None,
        snapshot_ttl: None,
        anchor: None,
        anchor_status: Default::default(),
    };

    let result2 = python_adapter.set_metric(&metric2).await;
    assert!(
        result2.is_ok(),
        "Failed to set second metric: {:?}",
        result2
    );
    let set_result2 = result2.unwrap();
    assert!(set_result2.verified, "Second breakpoint should be verified");
    eprintln!(
        "Second metric set on line {}: verified={}",
        set_result2.line, set_result2.verified
    );

    // Collect events - we expect events from BOTH metrics
    let mut metric1_events = Vec::new();
    let mut metric2_events = Vec::new();
    let collect_timeout = Duration::from_secs(8);
    let start = std::time::Instant::now();

    while start.elapsed() < collect_timeout {
        match timeout(Duration::from_millis(500), event_rx.recv()).await {
            Ok(Some(event)) => {
                eprintln!(
                    "Received event: metric_id={}, value={:?}",
                    event.metric_id.0, event.value_string
                );
                if event.metric_id == MetricId(1) {
                    metric1_events.push(event);
                } else if event.metric_id == MetricId(2) {
                    metric2_events.push(event);
                }
            }
            Ok(None) => {
                eprintln!("Event channel closed");
                break;
            }
            Err(_) => {
                // Timeout on recv, continue waiting
            }
        }
    }

    python_adapter.stop().await.ok();
    debugpy_process.kill().await.ok();
    std::fs::remove_file(&script_path).ok();

    // CRITICAL: Verify BOTH metrics received events
    eprintln!(
        "Results: metric1_events={}, metric2_events={}",
        metric1_events.len(),
        metric2_events.len()
    );

    assert!(
        !metric1_events.is_empty(),
        "First metric (symbol/string) should have received events! \
        If this fails, the race condition fix is broken - the second setBreakpoints \
        call is replacing the first breakpoint instead of adding to it."
    );

    assert!(
        !metric2_events.is_empty(),
        "Second metric (size/integer) should have received events!"
    );

    // Verify event content for metric1 (string values work)
    for event in &metric1_events {
        let value = event.value_string.as_ref().expect("Should have value");
        eprintln!("Metric1 event value: {}", value);
        assert!(
            value.contains("BTCUSD") || value.contains("ETHUSD"),
            "Symbol should be BTCUSD or ETHUSD, got: {}",
            value
        );
    }

    // Note: metric2 may have value_string=None if the expression returns an integer
    // that debugpy doesn't format as a string in the logpoint output.
    // The key test is that BOTH breakpoints are being hit (events received).
    for event in &metric2_events {
        eprintln!(
            "Metric2 event: value_string={:?}, value_json={:?}",
            event.value_string, event.value_json
        );
        // Just verify we got an event - the value format varies by expression type
    }

    eprintln!(
        "Test passed! Both metrics received events: metric1={}, metric2={}",
        metric1_events.len(),
        metric2_events.len()
    );
}
