//! End-to-End Tests for AdapterLifecycleManager Integration
//!
//! These tests verify the complete adapter lifecycle workflow:
//!
//! 1. Connection creation and lifecycle management
//! 2. Event routing through AdapterLifecycleManager
//! 3. Database persistence of events
//! 4. Multiple connections and concurrent operations
//!
//! Run with: cargo test --package detrix-application --test adapter_lifecycle_e2e_tests

use detrix_application::{
    AdapterLifecycleManager, ConnectionRepositoryRef, ConnectionService, DapAdapterFactoryRef,
    EventCaptureService, EventRepository, ManagedAdapterStatus, MetricRepositoryRef,
};
use detrix_config::constants::DEFAULT_EVENT_FLUSH_INTERVAL_MS;
use detrix_core::{
    ConnectionId, ConnectionStatus, MetricEvent, MetricId, SourceLanguage, SystemEvent,
};
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::broadcast;

mod test_support;
use test_support::{
    MockConnectionRepository, MockEventRepository, MockMetricRepository, StatefulMockAdapterFactory,
};

/// Delay to wait for events to be flushed (20% longer than flush interval)
const FLUSH_WAIT_MS: u64 = (DEFAULT_EVENT_FLUSH_INTERVAL_MS as f64 * 1.2) as u64;

// Note: We use tokio::sync::Mutex for all mocks in async contexts

// ============================================================================
// Mock Implementations (same pattern as connection_service_tests.rs)
// ============================================================================

/// Mock ConnectionRepository for testing

/// Mock EventRepository that stores events for verification

/// Mock MetricRepository that returns empty (no pre-existing metrics)

// ============================================================================
// Test Fixtures
// ============================================================================

struct E2eTestFixture {
    connection_repo: Arc<MockConnectionRepository>,
    event_repo: Arc<MockEventRepository>,
    adapter_factory: Arc<StatefulMockAdapterFactory>,
    lifecycle_manager: Arc<AdapterLifecycleManager>,
    connection_service: Arc<ConnectionService>,
    #[allow(dead_code)]
    broadcast_rx: broadcast::Receiver<MetricEvent>,
}

impl E2eTestFixture {
    async fn new() -> Self {
        let connection_repo = Arc::new(MockConnectionRepository::new());
        let event_repo = Arc::new(MockEventRepository::new());
        let event_capture_service = Arc::new(EventCaptureService::new(
            Arc::clone(&event_repo) as Arc<dyn EventRepository + Send + Sync>
        ));
        let (broadcast_tx, broadcast_rx) = broadcast::channel::<MetricEvent>(1024);
        let adapter_factory = Arc::new(StatefulMockAdapterFactory::new());
        let metric_repo = Arc::new(MockMetricRepository::new());

        let (system_event_tx, _) = broadcast::channel::<SystemEvent>(100);
        let lifecycle_manager = Arc::new(AdapterLifecycleManager::new(
            event_capture_service,
            broadcast_tx,
            system_event_tx.clone(),
            Arc::clone(&adapter_factory) as DapAdapterFactoryRef,
            metric_repo as MetricRepositoryRef,
            Arc::clone(&connection_repo) as ConnectionRepositoryRef,
        ));

        let connection_service = Arc::new(ConnectionService::new(
            Arc::clone(&connection_repo) as ConnectionRepositoryRef,
            Arc::clone(&lifecycle_manager),
            system_event_tx,
        ));

        Self {
            connection_repo,
            event_repo,
            adapter_factory,
            lifecycle_manager,
            connection_service,
            broadcast_rx,
        }
    }

    fn create_test_event(metric_id: u64, value: &str) -> MetricEvent {
        MetricEvent {
            id: None,
            metric_id: MetricId(metric_id),
            metric_name: format!("test_metric_{}", metric_id),
            connection_id: ConnectionId::new("test-conn"),
            timestamp: chrono::Utc::now().timestamp_micros(),
            thread_name: None,
            thread_id: None,
            value_json: format!(r#"{{"value": "{}"}}"#, value),
            value_numeric: None,
            value_string: Some(value.to_string()),
            value_boolean: None,
            is_error: false,
            error_type: None,
            error_message: None,
            request_id: None,
            session_id: None,
            stack_trace: None,
            memory_snapshot: None,
        }
    }
}

// ============================================================================
// E2E Test: Complete Workflow
// ============================================================================

/// Test the complete daemon workflow:
/// 1. Create a connection (simulates REST API call)
/// 2. Adapter starts and connects
/// 3. Events are generated by the adapter
/// 4. Events are routed through AdapterLifecycleManager
/// 5. Events are persisted to the database
/// 6. Connection can be disconnected cleanly
#[tokio::test]
async fn test_e2e_complete_daemon_workflow() {
    let fixture = E2eTestFixture::new().await;

    // Step 1: Create a connection (simulates: POST /api/v1/connections)
    let connection_id = fixture
        .connection_service
        .create_connection(
            "localhost".to_string(),
            5678,
            "python".to_string(),
            Some("test-trading-bot".to_string()),
            None,
            false,
        )
        .await
        .expect("Should create connection");

    assert_eq!(connection_id.0, "test-trading-bot");

    // Step 2: Verify connection is saved and status is Connected
    let connection = fixture
        .connection_repo
        .get_connection(&connection_id)
        .await
        .expect("Connection should exist");
    assert_eq!(connection.status, ConnectionStatus::Connected);
    assert_eq!(connection.host, "localhost");
    assert_eq!(connection.port, 5678);
    assert_eq!(connection.language, SourceLanguage::Python);

    // Step 3: Verify adapter is running via lifecycle manager
    assert!(
        fixture
            .connection_service
            .has_running_adapter(&connection_id)
            .await
    );

    let adapter_info = fixture.lifecycle_manager.list_adapters();
    assert_eq!(adapter_info.len(), 1);
    assert_eq!(adapter_info[0].connection_id.0, "test-trading-bot");
    assert_eq!(adapter_info[0].status, ManagedAdapterStatus::Running);

    // Step 4: Get the mock adapter and send events (simulates debugpy output)
    let mock_adapter = fixture
        .adapter_factory
        .get_adapter("localhost", 5678)
        .await
        .expect("Adapter should exist");

    // Give event listener time to start
    tokio::time::sleep(Duration::from_millis(100)).await;

    // Step 5: Send simulated events (like detrix_example_app.py would generate)
    for i in 0..5 {
        let event = E2eTestFixture::create_test_event(
            1,
            &format!("symbol=BTCUSD, qty={}, price={}", i + 1, 50000 + i * 100),
        );
        mock_adapter.send_event(event).await;
        tokio::time::sleep(Duration::from_millis(20)).await;
    }

    // Step 6: Wait for events to be processed (wait longer than flush interval)
    tokio::time::sleep(Duration::from_millis(FLUSH_WAIT_MS)).await;

    // Step 7: Verify events are persisted (simulates: sqlite3 check)
    let event_count = fixture.event_repo.event_count().await;
    assert_eq!(event_count, 5, "Should have captured 5 events");

    let events = fixture.event_repo.get_events().await;
    assert!(events.iter().all(|e| e.metric_name == "test_metric_1"));
    assert!(events
        .iter()
        .all(|e| e.value_string.as_ref().unwrap().contains("BTCUSD")));

    // Step 8: Disconnect (simulates: cleanup)
    fixture
        .connection_service
        .disconnect(&connection_id)
        .await
        .expect("Should disconnect");

    // Step 9: Verify cleanup
    let connection = fixture
        .connection_repo
        .get_connection(&connection_id)
        .await
        .unwrap();
    assert_eq!(connection.status, ConnectionStatus::Disconnected);
    assert!(
        !fixture
            .connection_service
            .has_running_adapter(&connection_id)
            .await
    );
    assert_eq!(fixture.lifecycle_manager.adapter_count().await, 0);
}

/// Test multiple connections can coexist and handle events independently
#[tokio::test]
async fn test_e2e_multiple_connections() {
    let fixture = E2eTestFixture::new().await;

    // Create 3 connections
    let conn1 = fixture
        .connection_service
        .create_connection(
            "localhost".to_string(),
            5678,
            "python".to_string(),
            Some("conn-1".to_string()),
            None,
            false,
        )
        .await
        .unwrap();

    let conn2 = fixture
        .connection_service
        .create_connection(
            "localhost".to_string(),
            5679,
            "python".to_string(),
            Some("conn-2".to_string()),
            None,
            false,
        )
        .await
        .unwrap();

    let conn3 = fixture
        .connection_service
        .create_connection(
            "localhost".to_string(),
            5680,
            "python".to_string(),
            Some("conn-3".to_string()),
            None,
            false,
        )
        .await
        .unwrap();

    // Verify all connections are active
    assert_eq!(fixture.connection_repo.connection_count().await, 3);
    assert_eq!(fixture.lifecycle_manager.adapter_count().await, 3);

    // Get adapters and send events
    let adapter1 = fixture
        .adapter_factory
        .get_adapter("localhost", 5678)
        .await
        .unwrap();
    let adapter2 = fixture
        .adapter_factory
        .get_adapter("localhost", 5679)
        .await
        .unwrap();
    let adapter3 = fixture
        .adapter_factory
        .get_adapter("localhost", 5680)
        .await
        .unwrap();

    tokio::time::sleep(Duration::from_millis(100)).await;

    // Send events from different adapters with different metric IDs
    for i in 0..3 {
        adapter1
            .send_event(E2eTestFixture::create_test_event(
                1,
                &format!("conn1-event-{}", i),
            ))
            .await;
        adapter2
            .send_event(E2eTestFixture::create_test_event(
                2,
                &format!("conn2-event-{}", i),
            ))
            .await;
        adapter3
            .send_event(E2eTestFixture::create_test_event(
                3,
                &format!("conn3-event-{}", i),
            ))
            .await;
        tokio::time::sleep(Duration::from_millis(20)).await;
    }

    // Wait for events to be flushed (wait longer than flush interval)
    tokio::time::sleep(Duration::from_millis(FLUSH_WAIT_MS)).await;

    // Verify all events are captured
    let total_events = fixture.event_repo.event_count().await;
    assert_eq!(
        total_events, 9,
        "Should have captured 9 events (3 per connection)"
    );

    // Verify events are from different metrics
    let events = fixture.event_repo.get_events().await;
    let metric1_events: Vec<_> = events
        .iter()
        .filter(|e| e.metric_id == MetricId(1))
        .collect();
    let metric2_events: Vec<_> = events
        .iter()
        .filter(|e| e.metric_id == MetricId(2))
        .collect();
    let metric3_events: Vec<_> = events
        .iter()
        .filter(|e| e.metric_id == MetricId(3))
        .collect();

    assert_eq!(metric1_events.len(), 3);
    assert_eq!(metric2_events.len(), 3);
    assert_eq!(metric3_events.len(), 3);

    // Disconnect one connection, others should continue working
    fixture.connection_service.disconnect(&conn2).await.unwrap();

    assert_eq!(fixture.lifecycle_manager.adapter_count().await, 2);
    assert!(fixture.connection_service.has_running_adapter(&conn1).await);
    assert!(!fixture.connection_service.has_running_adapter(&conn2).await);
    assert!(fixture.connection_service.has_running_adapter(&conn3).await);

    // Cleanup remaining
    fixture.connection_service.disconnect(&conn1).await.unwrap();
    fixture.connection_service.disconnect(&conn3).await.unwrap();

    assert_eq!(fixture.lifecycle_manager.adapter_count().await, 0);
}

/// Test that events are properly broadcast for real-time streaming
#[tokio::test]
async fn test_e2e_event_broadcast_for_streaming() {
    let connection_repo = Arc::new(MockConnectionRepository::new());
    let event_repo = Arc::new(MockEventRepository::new());
    let event_capture_service = Arc::new(EventCaptureService::new(
        Arc::clone(&event_repo) as Arc<dyn EventRepository + Send + Sync>
    ));
    let (broadcast_tx, mut broadcast_rx) = broadcast::channel::<MetricEvent>(1024);
    let adapter_factory = Arc::new(StatefulMockAdapterFactory::new());
    let metric_repo = Arc::new(MockMetricRepository::new());

    let (system_event_tx, _) = broadcast::channel::<SystemEvent>(100);
    let lifecycle_manager = Arc::new(AdapterLifecycleManager::new(
        event_capture_service,
        broadcast_tx,
        system_event_tx.clone(),
        Arc::clone(&adapter_factory) as DapAdapterFactoryRef,
        metric_repo as MetricRepositoryRef,
        Arc::clone(&connection_repo) as ConnectionRepositoryRef,
    ));

    let connection_service = Arc::new(ConnectionService::new(
        Arc::clone(&connection_repo) as ConnectionRepositoryRef,
        Arc::clone(&lifecycle_manager),
        system_event_tx,
    ));

    // Create connection
    connection_service
        .create_connection(
            "localhost".to_string(),
            5678,
            "python".to_string(),
            Some("stream-test".to_string()),
            None,
            false,
        )
        .await
        .unwrap();

    let mock_adapter = adapter_factory
        .get_adapter("localhost", 5678)
        .await
        .unwrap();

    tokio::time::sleep(Duration::from_millis(100)).await;

    // Send an event
    let test_event = E2eTestFixture::create_test_event(1, "streaming-test-value");
    mock_adapter.send_event(test_event.clone()).await;

    // Receive from broadcast channel (simulates WebSocket/gRPC streaming)
    let received = tokio::time::timeout(Duration::from_millis(500), broadcast_rx.recv()).await;

    assert!(received.is_ok(), "Should receive broadcast within timeout");
    let received_event = received.unwrap().unwrap();
    assert_eq!(received_event.metric_name, "test_metric_1");
    assert_eq!(
        received_event.value_string,
        Some("streaming-test-value".to_string())
    );
}

/// Test concurrent connection creation (stress test)
#[tokio::test]
async fn test_e2e_concurrent_connection_creation() {
    let fixture = E2eTestFixture::new().await;

    // Create 10 connections concurrently using JoinSet
    let mut join_set = tokio::task::JoinSet::new();
    for i in 0..10 {
        let service = Arc::clone(&fixture.connection_service);
        join_set.spawn(async move {
            service
                .create_connection(
                    "localhost".to_string(),
                    5700 + i as u16,
                    "python".to_string(),
                    Some(format!("concurrent-conn-{}", i)),
                    None,
                    false,
                )
                .await
        });
    }

    // Wait for all with timeout (detect deadlocks)
    let mut success_count = 0;
    let deadline = tokio::time::Instant::now() + Duration::from_secs(10);

    while let Some(result) = tokio::time::timeout_at(deadline, join_set.join_next())
        .await
        .ok()
        .flatten()
    {
        assert!(result.is_ok(), "Task panicked");
        assert!(result.unwrap().is_ok(), "Connection creation failed");
        success_count += 1;
    }

    assert_eq!(
        success_count, 10,
        "Connection creation timed out - possible deadlock"
    );

    // Verify all connections exist
    assert_eq!(fixture.connection_repo.connection_count().await, 10);
    assert_eq!(fixture.lifecycle_manager.adapter_count().await, 10);

    // Cleanup all
    fixture.lifecycle_manager.stop_all().await.unwrap();
    assert_eq!(fixture.lifecycle_manager.adapter_count().await, 0);
}

/// Test connection recreation after disconnect
#[tokio::test]
async fn test_e2e_connection_recreation() {
    let fixture = E2eTestFixture::new().await;

    // Create connection
    let conn_id = fixture
        .connection_service
        .create_connection(
            "localhost".to_string(),
            5678,
            "python".to_string(),
            Some("recreate-test".to_string()),
            None,
            false,
        )
        .await
        .unwrap();

    // Send some events
    let adapter = fixture
        .adapter_factory
        .get_adapter("localhost", 5678)
        .await
        .unwrap();
    tokio::time::sleep(Duration::from_millis(50)).await;
    adapter
        .send_event(E2eTestFixture::create_test_event(1, "before-disconnect"))
        .await;
    // Wait for events to be flushed (wait longer than flush interval)
    tokio::time::sleep(Duration::from_millis(FLUSH_WAIT_MS)).await;

    let events_before = fixture.event_repo.event_count().await;
    assert_eq!(events_before, 1);

    // Disconnect
    fixture
        .connection_service
        .disconnect(&conn_id)
        .await
        .unwrap();

    // Recreate with same ID
    let new_conn_id = fixture
        .connection_service
        .create_connection(
            "localhost".to_string(),
            5678,
            "python".to_string(),
            Some("recreate-test".to_string()),
            None,
            false,
        )
        .await
        .unwrap();

    assert_eq!(new_conn_id.0, "recreate-test");

    // Send more events
    let new_adapter = fixture
        .adapter_factory
        .get_adapter("localhost", 5678)
        .await
        .unwrap();
    tokio::time::sleep(Duration::from_millis(50)).await;
    new_adapter
        .send_event(E2eTestFixture::create_test_event(1, "after-reconnect"))
        .await;
    // Wait for events to be flushed (wait longer than flush interval)
    tokio::time::sleep(Duration::from_millis(FLUSH_WAIT_MS)).await;

    // Verify new events are captured
    let events_after = fixture.event_repo.event_count().await;
    assert_eq!(events_after, 2, "Should have events from both sessions");

    let events = fixture.event_repo.get_events().await;
    assert!(events.iter().any(|e| e
        .value_string
        .as_ref()
        .unwrap()
        .contains("before-disconnect")));
    assert!(events
        .iter()
        .any(|e| e.value_string.as_ref().unwrap().contains("after-reconnect")));
}

/// Test that adapter is properly cleaned up when connection service stops it
#[tokio::test]
async fn test_adapter_lifecycle_manager_broadcasts_events() {
    let fixture = E2eTestFixture::new().await;

    let conn_id = fixture
        .connection_service
        .create_connection(
            "localhost".to_string(),
            5678,
            "python".to_string(),
            None,
            None,
            false,
        )
        .await
        .unwrap();

    // Verify adapter started
    let adapter = fixture
        .adapter_factory
        .get_adapter("localhost", 5678)
        .await
        .unwrap();
    assert!(adapter.was_started());
    assert!(!adapter.was_stopped());

    // Disconnect
    fixture
        .connection_service
        .disconnect(&conn_id)
        .await
        .unwrap();

    // Verify adapter stopped
    assert!(adapter.was_stopped());
}

/// Test stop_all clears everything cleanly
#[tokio::test]
async fn test_e2e_stop_all_cleanup() {
    let fixture = E2eTestFixture::new().await;

    // Create multiple connections
    for i in 0..5 {
        fixture
            .connection_service
            .create_connection(
                "localhost".to_string(),
                5700 + i as u16,
                "python".to_string(),
                Some(format!("stop-all-conn-{}", i)),
                None,
                false,
            )
            .await
            .unwrap();
    }

    assert_eq!(fixture.lifecycle_manager.adapter_count().await, 5);

    // Stop all via lifecycle manager
    fixture.lifecycle_manager.stop_all().await.unwrap();

    assert_eq!(fixture.lifecycle_manager.adapter_count().await, 0);

    // All adapters should be stopped
    for i in 0..5 {
        let adapter = fixture
            .adapter_factory
            .get_adapter("localhost", 5700 + i as u16)
            .await
            .unwrap();
        assert!(adapter.was_stopped());
    }
}

/// Test high-volume event processing
#[tokio::test]
async fn test_e2e_high_volume_events() {
    let fixture = E2eTestFixture::new().await;

    fixture
        .connection_service
        .create_connection(
            "localhost".to_string(),
            5678,
            "python".to_string(),
            Some("high-volume".to_string()),
            None,
            false,
        )
        .await
        .unwrap();

    let adapter = fixture
        .adapter_factory
        .get_adapter("localhost", 5678)
        .await
        .unwrap();
    tokio::time::sleep(Duration::from_millis(100)).await;

    // Send 100 events rapidly
    for i in 0..100 {
        adapter
            .send_event(E2eTestFixture::create_test_event(
                1,
                &format!("event-{}", i),
            ))
            .await;
    }

    // Wait for processing
    tokio::time::sleep(Duration::from_millis(500)).await;

    // All events should be captured
    let event_count = fixture.event_repo.event_count().await;
    assert_eq!(event_count, 100, "Should capture all 100 events");
}

/// Test that connection status is properly updated when debugger crashes
///
/// This test verifies that when a debugger process terminates unexpectedly:
/// 1. The cleanup task detects the crash
/// 2. The connection status is updated to Disconnected in the database
/// 3. The `detrix status` command will correctly show the connection as disconnected
#[tokio::test]
async fn test_e2e_connection_status_updated_on_crash() {
    let fixture = E2eTestFixture::new().await;

    // Create first connection (simulating Python debugger)
    let conn_id_python = fixture
        .connection_service
        .create_connection(
            "localhost".to_string(),
            5680,
            "python".to_string(),
            Some("python-conn".to_string()),
            None,
            false,
        )
        .await
        .unwrap();

    // Create second connection (simulating Rust debugger)
    let conn_id_rust = fixture
        .connection_service
        .create_connection(
            "localhost".to_string(),
            5681,
            "rust".to_string(),
            Some("rust-conn".to_string()),
            None,
            false,
        )
        .await
        .unwrap();

    // Wait for adapters to start
    tokio::time::sleep(Duration::from_millis(50)).await;

    // Verify both connections are Connected
    let python_conn = fixture
        .connection_repo
        .get_connection(&conn_id_python)
        .await
        .unwrap();
    let rust_conn = fixture
        .connection_repo
        .get_connection(&conn_id_rust)
        .await
        .unwrap();

    assert!(
        matches!(python_conn.status, ConnectionStatus::Connected),
        "Python connection should be Connected, got {:?}",
        python_conn.status
    );
    assert!(
        matches!(rust_conn.status, ConnectionStatus::Connected),
        "Rust connection should be Connected, got {:?}",
        rust_conn.status
    );

    // Simulate Python debugger crash by closing the event channel
    let python_adapter = fixture
        .adapter_factory
        .get_adapter("localhost", 5680)
        .await
        .unwrap();
    python_adapter.simulate_crash().await;

    // Wait for cleanup task to process the crash
    tokio::time::sleep(Duration::from_millis(200)).await;

    // Verify Python connection is now Disconnected
    let python_conn_after = fixture
        .connection_repo
        .get_connection(&conn_id_python)
        .await
        .unwrap();
    assert!(
        matches!(python_conn_after.status, ConnectionStatus::Disconnected),
        "Python connection should be Disconnected after crash, got {:?}",
        python_conn_after.status
    );

    // Verify Rust connection is still Connected
    let rust_conn_still = fixture
        .connection_repo
        .get_connection(&conn_id_rust)
        .await
        .unwrap();
    assert!(
        matches!(rust_conn_still.status, ConnectionStatus::Connected),
        "Rust connection should still be Connected, got {:?}",
        rust_conn_still.status
    );

    // Simulate Rust debugger crash
    let rust_adapter = fixture
        .adapter_factory
        .get_adapter("localhost", 5681)
        .await
        .unwrap();
    rust_adapter.simulate_crash().await;

    // Wait for cleanup
    tokio::time::sleep(Duration::from_millis(200)).await;

    // Verify both connections are now Disconnected
    let python_conn_final = fixture
        .connection_repo
        .get_connection(&conn_id_python)
        .await
        .unwrap();
    let rust_conn_final = fixture
        .connection_repo
        .get_connection(&conn_id_rust)
        .await
        .unwrap();

    assert!(
        matches!(python_conn_final.status, ConnectionStatus::Disconnected),
        "Python connection should still be Disconnected, got {:?}",
        python_conn_final.status
    );
    assert!(
        matches!(rust_conn_final.status, ConnectionStatus::Disconnected),
        "Rust connection should be Disconnected after crash, got {:?}",
        rust_conn_final.status
    );

    // Verify adapter count is 0 after both crashes
    assert_eq!(
        fixture.lifecycle_manager.adapter_count().await,
        0,
        "No adapters should remain after both crashes"
    );
}
