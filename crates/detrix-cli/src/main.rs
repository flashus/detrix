//! Detrix CLI - LLM-first dynamic observability platform
//!
//! Commands:
//! - serve: Start Detrix server
//! - metric: Manage metrics (observation points)
//! - event: Query and stream metric events
//! - mcp: Start MCP server for LLM integration

use anyhow::Result;
use clap::{Parser, Subcommand};
use detrix_config::constants::{DEFAULT_ADAPTER_PORT, DEFAULT_GRPC_PORT, DEFAULT_REST_PORT};
use detrix_config::paths::DEFAULT_CONFIG_FILENAME;

mod commands;
mod context;
mod grpc_client;
mod output;
mod utils;

pub use context::{ClientContext, ClientContextError};

// Include build info generated by build.rs
include!(concat!(env!("OUT_DIR"), "/build_info.rs"));

use output::OutputFormat;

/// Generate long version string with build time
fn long_version() -> &'static str {
    use std::sync::OnceLock;
    static VERSION: OnceLock<String> = OnceLock::new();
    VERSION.get_or_init(|| format!("{}\nBuild time: {}", env!("CARGO_PKG_VERSION"), BUILD_TIME))
}

#[derive(Parser)]
#[command(name = "detrix")]
#[command(about = "LLM-first dynamic observability platform", long_about = None)]
#[command(version, long_version = long_version())]
struct Cli {
    #[command(subcommand)]
    command: Commands,

    /// Enable debug logging
    #[arg(short, long, global = true)]
    debug: bool,

    /// Config file path
    #[arg(short, long, global = true, default_value_t = String::from(DEFAULT_CONFIG_FILENAME))]
    config: String,

    /// Minimal output (IDs only, for scripting)
    #[arg(short, long, global = true)]
    quiet: bool,

    /// Output format
    #[arg(long, global = true, default_value = "table", value_enum)]
    format: OutputFormat,

    /// Disable colored output
    #[arg(long, global = true)]
    no_color: bool,
}

#[derive(Subcommand)]
enum Commands {
    /// Start Detrix server and set up metrics
    Serve {
        /// Python script to attach to
        #[arg(short, long)]
        script: Option<String>,

        /// Port for debugpy
        #[arg(short, long, default_value_t = DEFAULT_ADAPTER_PORT)]
        port: u16,

        /// Start gRPC server
        #[arg(long)]
        grpc: bool,

        /// gRPC server port (requires --grpc)
        #[arg(long, default_value_t = DEFAULT_GRPC_PORT)]
        grpc_port: u16,

        /// Run with PID file management (internal - use 'daemon start' instead)
        #[arg(long, hide = true)]
        daemon: bool,

        /// PID file path (internal - use 'daemon start' instead)
        #[arg(long, hide = true)]
        pid_file: Option<String>,

        /// Marker that daemon was spawned by MCP (internal)
        #[arg(long, hide = true)]
        mcp_spawned: bool,
    },

    /// Manage metric groups
    Group {
        #[command(subcommand)]
        action: commands::group::GroupAction,
    },

    /// Query and stream metric events
    Event {
        #[command(subcommand)]
        action: commands::event::EventAction,
    },

    /// Show system status
    Status {
        /// Show detailed information (connections and metrics)
        #[arg(long, short)]
        verbose: bool,
    },

    /// Wake the system (start observing)
    Wake,

    /// Sleep the system (pause observing)
    Sleep,

    /// Manage configuration
    Config {
        #[command(subcommand)]
        action: commands::config::ConfigAction,
    },

    /// Validate an expression for safety
    Validate {
        /// Expression to validate
        expression: String,

        /// Language (python, go, rust) - required
        #[arg(long, short)]
        language: String,
    },

    /// Inspect a file to discover observable variables
    ///
    /// Parses source code to find observable variables, functions, and
    /// suggested observation points.
    ///
    /// Example:
    ///   detrix inspect path/to/file.py --line 42
    ///   detrix inspect path/to/file.py --find-variable request
    Inspect {
        /// File path to inspect
        file: std::path::PathBuf,

        /// Specific line number to inspect
        #[arg(long, short)]
        line: Option<u32>,

        /// Find specific variable
        #[arg(long)]
        find_variable: Option<String>,
    },

    /// Manage metrics (observation points)
    Metric {
        #[command(subcommand)]
        action: commands::metric::MetricAction,
    },

    /// Start MCP (Model Context Protocol) server for LLM integration
    ///
    /// By default, runs in bridge mode connecting to a daemon.
    /// If daemon is not running, auto-spawns it.
    /// Use --no-daemon for direct mode (own storage/adapter).
    Mcp {
        /// Transport mode (currently only stdio supported)
        #[arg(long, default_value = "stdio")]
        transport: String,

        /// Run in direct mode without daemon (own storage/adapter)
        /// Use this for testing or when you don't want a persistent daemon
        #[arg(long)]
        no_daemon: bool,

        /// Daemon HTTP port for bridge mode
        #[arg(long, default_value_t = DEFAULT_REST_PORT)]
        daemon_port: u16,
    },

    /// Manage Detrix daemon lifecycle
    Daemon {
        /// Daemon action (start/stop/restart/status)
        #[command(subcommand)]
        action: commands::daemon::DaemonAction,

        /// PID file path
        #[arg(long)]
        pid_file: Option<String>,
    },

    /// Show output configuration status (GELF/Graylog)
    Output {
        /// Test connection to the configured output
        #[arg(long)]
        test: bool,
    },

    /// List all running detrix processes
    Ps,

    /// Manage debugger connections
    Connection {
        #[command(subcommand)]
        action: commands::connection::ConnectionAction,
    },

    /// Start LLDB DAP server for Rust debugging
    ///
    /// Makes lldb-dap behave like debugpy/delve: starts the program through
    /// the debugger and listens for DAP connections.
    ///
    /// Example:
    ///   detrix lldb-serve ./target/debug/my_program --listen localhost:4711 --stop-on-entry
    #[command(name = "lldb-serve")]
    LldbServe(commands::lldb_serve::LldbServeArgs),

    /// Parse git diff and create metrics from debug statements
    ///
    /// Automatically detects print/log statements in diffs and creates
    /// corresponding metrics for dynamic observation.
    ///
    /// Example:
    ///   git diff | detrix diff --stdin --connection myconn
    Diff(commands::diff::DiffArgs),

    /// Query system events (crashes, connection changes, errors)
    #[command(name = "system-event")]
    SystemEvent {
        #[command(subcommand)]
        action: commands::system_event::SystemEventAction,
    },

    /// Show MCP tool usage statistics
    Usage,

    /// Initialize Detrix configuration
    ///
    /// Creates configuration file if it doesn't exist. By default, creates a
    /// minimal config with only essential settings. Use --full for all options.
    ///
    /// Path resolution priority:
    /// 1. `--path <custom>` (explicit argument)
    /// 2. DETRIX_HOME environment variable
    /// 3. ~/detrix/detrix.toml (default)
    ///
    /// Example:
    ///   detrix init              # Minimal config (recommended for new users)
    ///   detrix init --full       # Full config with all options
    ///   detrix init --path /custom/path/detrix.toml
    ///   detrix init --force      # Overwrite existing config
    Init {
        /// Custom path for config file
        #[arg(long)]
        path: Option<std::path::PathBuf>,

        /// Overwrite existing config file
        #[arg(long)]
        force: bool,

        /// Create full config with all options and extensive comments
        #[arg(long)]
        full: bool,
    },
}

#[tokio::main]
async fn main() -> Result<()> {
    let cli = Cli::parse();

    // Create client context (loads config and discovers endpoints once)
    // This is done before logging init so we can use config for MCP log path
    let ctx = context::ClientContext::new().ok();

    // Initialize logging
    // MCP needs stderr for logs (stdout is JSON-RPC)
    // lldb-serve needs stderr for logs (stdout/stdin is DAP)
    // Daemon mode can optionally use file logging with rotation
    let use_stderr = matches!(cli.command, Commands::Mcp { .. } | Commands::LldbServe(_));
    let is_lldb_serve = matches!(cli.command, Commands::LldbServe(_));

    // Check if this is daemon mode with file logging enabled
    let is_daemon_with_file_logging = matches!(&cli.command, Commands::Serve { daemon: true, .. })
        && ctx
            .as_ref()
            .is_some_and(|c| c.config.daemon.logging.file_logging_enabled);

    // Determine file log path and UTC setting based on mode
    let (file_log_path, use_utc) = if use_stderr {
        // MCP/lldb-serve: log to PID-specific file
        ctx.as_ref()
            .map(|c| {
                let path = match &cli.command {
                    Commands::LldbServe(_) => c.config.daemon.logging.current_lldb_serve_log_path(),
                    _ => c.config.daemon.logging.current_mcp_log_path(),
                };
                (Some(path), c.config.daemon.logging.use_utc)
            })
            .unwrap_or((None, false))
    } else if is_daemon_with_file_logging {
        // Daemon mode: log to daemon.log with daily rotation
        ctx.as_ref()
            .map(|c| {
                (
                    Some(c.config.daemon.logging.daemon_log_path()),
                    c.config.daemon.logging.use_utc,
                )
            })
            .unwrap_or((None, false))
    } else {
        // Other commands: stdout only
        (
            None,
            ctx.as_ref()
                .map(|c| c.config.daemon.logging.use_utc)
                .unwrap_or(false),
        )
    };

    init_logging(
        cli.debug,
        use_stderr,
        is_lldb_serve,
        is_daemon_with_file_logging,
        file_log_path,
        use_utc,
    );

    // Set UTC/local timestamp preference for output formatting
    output::set_use_utc(use_utc);

    // Helper to get context for client commands (fails if context couldn't be created)
    let require_ctx = || -> Result<&context::ClientContext> {
        ctx.as_ref().ok_or_else(|| {
            anyhow::anyhow!(
                "Failed to load configuration. Run 'detrix init' to create a default config."
            )
        })
    };

    // Execute command
    match cli.command {
        // Server-side commands (serve/mcp load config directly, daemon uses ClientContext)
        Commands::Serve {
            script,
            port,
            grpc,
            grpc_port,
            daemon,
            pid_file,
            mcp_spawned,
        } => {
            commands::serve::run(
                &cli.config,
                script,
                port,
                grpc,
                grpc_port,
                daemon,
                pid_file,
                mcp_spawned,
            )
            .await
        }
        Commands::Mcp {
            transport,
            no_daemon,
            daemon_port,
        } => commands::mcp::run(&cli.config, &transport, no_daemon, daemon_port).await,
        Commands::Daemon { action, pid_file } => {
            let pid_path = pid_file.map(std::path::PathBuf::from);
            commands::daemon::run(require_ctx()?, action, pid_path).await
        }

        // Utility commands (don't need context)
        Commands::Ps => commands::ps::run().await,
        Commands::LldbServe(args) => commands::lldb_serve::run(args),
        Commands::Init { path, force, full } => commands::init::run(path, force, full),

        // Client commands (use ClientContext for endpoints and config)
        Commands::Group { action } => {
            commands::group::run(require_ctx()?, action, cli.format, cli.quiet, cli.no_color).await
        }
        Commands::Event { action } => {
            commands::event::run(require_ctx()?, action, cli.format, cli.quiet, cli.no_color).await
        }
        Commands::Status { verbose } => {
            commands::status::run(require_ctx()?, cli.format, cli.quiet, cli.no_color, verbose)
                .await
        }
        Commands::Wake => {
            commands::status::wake(require_ctx()?, cli.format, cli.quiet, cli.no_color).await
        }
        Commands::Sleep => {
            commands::status::sleep(require_ctx()?, cli.format, cli.quiet, cli.no_color).await
        }
        Commands::Config { action } => {
            commands::config::run(require_ctx()?, action, cli.format, cli.quiet, cli.no_color).await
        }
        Commands::Validate {
            expression,
            language,
        } => {
            commands::validate::run(
                require_ctx()?,
                expression,
                language,
                cli.format,
                cli.quiet,
                cli.no_color,
            )
            .await
        }
        Commands::Inspect {
            file,
            line,
            find_variable,
        } => {
            commands::inspect::run(
                require_ctx()?,
                file,
                line,
                find_variable,
                cli.format,
                cli.quiet,
                cli.no_color,
            )
            .await
        }
        Commands::Metric { action } => {
            commands::metric::run(require_ctx()?, action, cli.format, cli.quiet, cli.no_color).await
        }
        Commands::Output { test } => commands::output::run(require_ctx()?, test).await,
        Commands::Connection { action } => {
            commands::connection::run(require_ctx()?, action, cli.format, cli.quiet, cli.no_color)
                .await
        }
        Commands::Diff(args) => {
            commands::diff::run(require_ctx()?, args, cli.format, cli.quiet, cli.no_color).await
        }
        Commands::SystemEvent { action } => {
            commands::system_event::run(require_ctx()?, action, cli.format, cli.quiet, cli.no_color)
                .await
        }
        Commands::Usage => {
            commands::usage::run(require_ctx()?, cli.format, cli.quiet, cli.no_color).await
        }
    }
}

/// Log guard to keep file logging active (must be held for program duration)
static MCP_LOG_GUARD: std::sync::OnceLock<detrix_logging::WorkerGuard> = std::sync::OnceLock::new();

fn init_logging(
    debug: bool,
    use_stderr: bool,
    is_lldb_serve: bool,
    is_daemon_with_file_logging: bool,
    log_path: Option<std::path::PathBuf>,
    use_utc: bool,
) {
    use detrix_logging::{init, init_with_file, init_with_file_and_stderr, LogConfig, LogOutput};

    // Build base config with timestamp format from detrix.toml
    let base_config = || {
        let config = LogConfig::new().debug(debug);
        if use_utc {
            config.utc()
        } else {
            config
        }
    };

    if use_stderr {
        // MCP/lldb-serve mode: log to both file and stderr
        // This helps debug issues when IDE's MCP stderr isn't visible
        let log_path = log_path.unwrap_or_else(detrix_config::paths::default_mcp_log_path);
        let mut config = base_config();

        // For lldb-serve: only show ERROR level on stderr, full logs go to file
        // This reduces noise on console while keeping detailed logs for debugging
        if is_lldb_serve {
            config = config.stderr_min_level(detrix_logging::Level::ERROR);
        }

        match init_with_file_and_stderr(config, &log_path) {
            Ok(guard) => {
                let _ = MCP_LOG_GUARD.set(guard);
            }
            Err(e) => {
                // Fall back to stderr-only logging if file logging fails
                eprintln!(
                    "Warning: Failed to initialize file logging: {}. Using stderr only.",
                    e
                );
                let config = base_config().output(LogOutput::Stderr);
                init(config);
            }
        }
    } else if is_daemon_with_file_logging {
        // Daemon mode with file logging: log to file with daily rotation
        let log_path = log_path.unwrap_or_else(detrix_config::paths::default_daemon_log_path);
        let config = base_config();
        match init_with_file(config, &log_path) {
            Ok(guard) => {
                let _ = MCP_LOG_GUARD.set(guard);
            }
            Err(e) => {
                // Fall back to stdout logging if file logging fails
                eprintln!(
                    "Warning: Failed to initialize daemon file logging: {}. Using stdout.",
                    e
                );
                let config = base_config().output(LogOutput::Stdout);
                init(config);
            }
        }
    } else {
        // Normal mode: log to stdout only
        let config = base_config().output(LogOutput::Stdout);
        init(config);
    }
}
