//! Authentication and connection error utilities for MCP bridge

use detrix_config::constants::ENV_DETRIX_TOKEN;
use detrix_logging::debug;
#[cfg(unix)]
use detrix_logging::warn;

/// Discover auth token for daemon communication
///
/// Token is discovered in priority order:
/// 1. DETRIX_TOKEN environment variable
/// 2. Token file at ~/.detrix/mcp-token (auto-generated by daemon)
///
/// Returns None if no token is found (auth may be disabled).
///
/// Uses exponential backoff when reading the token file to handle
/// file system timing issues after daemon restart.
///
/// Security: On Unix, verifies token file has secure permissions (0600)
/// and is owned by the current user.
pub fn discover_auth_token() -> Option<String> {
    // 1. Check environment variable (highest priority)
    if let Ok(token) = std::env::var(ENV_DETRIX_TOKEN) {
        if !token.is_empty() {
            debug!("Using auth token from DETRIX_TOKEN environment variable");
            return Some(token);
        }
    }

    // 2. Check well-known token file (auto-generated by daemon)
    // Use exponential backoff to handle file system timing issues.
    // Token should exist if daemon is healthy, so 2s timeout is sufficient.
    let token_path = detrix_config::paths::mcp_token_path();
    let mut delay = std::time::Duration::from_millis(50);
    let max_delay = std::time::Duration::from_millis(200);
    let deadline = std::time::Instant::now() + std::time::Duration::from_secs(2);

    while std::time::Instant::now() < deadline {
        // Security check: verify file permissions before reading
        #[cfg(unix)]
        {
            use std::os::unix::fs::MetadataExt;
            if let Ok(meta) = std::fs::metadata(&token_path) {
                let mode = meta.mode();
                // Check permissions: should be 0600 (owner read/write only)
                // Mask out file type bits, check only permission bits
                if mode & 0o077 != 0 {
                    warn!(
                        "Token file {} has insecure permissions ({:o}), skipping",
                        token_path.display(),
                        mode & 0o777
                    );
                    return None;
                }
                // Check owner matches current user
                let current_uid = nix::unistd::getuid().as_raw();
                if meta.uid() != current_uid {
                    warn!(
                        "Token file {} owned by UID {}, expected {} (current user)",
                        token_path.display(),
                        meta.uid(),
                        current_uid
                    );
                    return None;
                }
            }
        }

        if let Ok(token) = std::fs::read_to_string(&token_path) {
            let token = token.trim().to_string();
            if !token.is_empty() {
                debug!("Using auth token from {}", token_path.display());
                return Some(token);
            }
        }
        std::thread::sleep(delay);
        delay = std::cmp::min(delay * 2, max_delay);
    }

    debug!("No auth token found (auth may be disabled)");
    None
}

/// Check if an error is a connection-related error
///
/// Uses proper error type detection instead of fragile string matching.
/// Handles reqwest errors (is_connect, is_timeout) and std::io errors.
pub fn is_connection_error(error: &anyhow::Error) -> bool {
    // Check for reqwest-specific connection errors
    if let Some(reqwest_err) = error.downcast_ref::<reqwest::Error>() {
        return reqwest_err.is_connect() || reqwest_err.is_timeout();
    }

    // Check for std::io connection errors
    if let Some(io_err) = error.downcast_ref::<std::io::Error>() {
        return matches!(
            io_err.kind(),
            std::io::ErrorKind::ConnectionRefused
                | std::io::ErrorKind::ConnectionReset
                | std::io::ErrorKind::ConnectionAborted
                | std::io::ErrorKind::NotConnected
                | std::io::ErrorKind::BrokenPipe
                | std::io::ErrorKind::TimedOut
        );
    }

    // Walk the error chain to find nested connection errors
    for cause in error.chain().skip(1) {
        if let Some(reqwest_err) = cause.downcast_ref::<reqwest::Error>() {
            if reqwest_err.is_connect() || reqwest_err.is_timeout() {
                return true;
            }
        }
        if let Some(io_err) = cause.downcast_ref::<std::io::Error>() {
            if matches!(
                io_err.kind(),
                std::io::ErrorKind::ConnectionRefused
                    | std::io::ErrorKind::ConnectionReset
                    | std::io::ErrorKind::ConnectionAborted
                    | std::io::ErrorKind::NotConnected
                    | std::io::ErrorKind::BrokenPipe
                    | std::io::ErrorKind::TimedOut
            ) {
                return true;
            }
        }
    }

    // Fallback: check string for common connection error patterns
    // This handles cases where error types are wrapped in other ways
    let error_str = error.to_string().to_lowercase();
    error_str.contains("connection refused")
        || error_str.contains("connection reset")
        || error_str.contains("broken pipe")
        || error_str.contains("timed out")
        || error_str.contains("connect error")
}
