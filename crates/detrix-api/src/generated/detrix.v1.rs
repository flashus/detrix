// This file is @generated by prost-build.
/// Metadata sent with every request
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestMetadata {
    /// Client-provided or auto-generated
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
}
/// Metadata returned with every response
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResponseMetadata {
    /// Unix timestamp (microseconds)
    #[prost(int64, tag = "1")]
    pub timestamp: i64,
    /// Echo back request_id
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    /// Server identifier (for distributed setups)
    #[prost(string, tag = "3")]
    pub server_id: ::prost::alloc::string::String,
}
/// Standard error response
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Error {
    #[prost(bool, tag = "1")]
    pub error: bool,
    #[prost(string, tag = "2")]
    pub error_code: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub error_type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "5")]
    pub error_details: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(int64, tag = "6")]
    pub timestamp: i64,
    #[prost(string, tag = "7")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "8")]
    pub traceback: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "9")]
    pub help_url: ::core::option::Option<::prost::alloc::string::String>,
}
/// Empty message
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Empty {}
/// Location in source code
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[serde(try_from = "crate::location_serde::LocationInput")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Location {
    #[prost(string, tag = "1")]
    pub file: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub line: u32,
}
/// Metric mode configuration
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MetricMode {
    #[prost(oneof = "metric_mode::Mode", tags = "1, 2, 3, 4, 5")]
    pub mode: ::core::option::Option<metric_mode::Mode>,
}
/// Nested message and enum types in `MetricMode`.
pub mod metric_mode {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Mode {
        #[prost(message, tag = "1")]
        Stream(super::StreamMode),
        /// Capture every Nth hit
        #[prost(message, tag = "2")]
        Sample(super::SampleMode),
        #[prost(message, tag = "3")]
        First(super::FirstMode),
        #[prost(message, tag = "4")]
        Throttle(super::ThrottleMode),
        /// Capture every N seconds
        #[prost(message, tag = "5")]
        SampleInterval(super::SampleIntervalMode),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StreamMode {}
/// Hit-based sampling: capture every Nth hit
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SampleMode {
    /// Capture every N hits (e.g., rate=100 means every 100th hit)
    #[prost(uint32, tag = "1")]
    pub rate: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FirstMode {}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ThrottleMode {
    #[prost(uint32, tag = "1")]
    pub max_per_second: u32,
}
/// Time-based sampling: capture every N seconds
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SampleIntervalMode {
    /// Capture every N seconds (e.g., seconds=60 means every 60 seconds)
    #[prost(uint32, tag = "1")]
    pub seconds: u32,
}
/// Error count for a specific error code
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct McpErrorCount {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub count: u64,
}
/// Workflow statistics
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct McpWorkflowStats {
    #[prost(uint64, tag = "1")]
    pub correct_workflows: u64,
    #[prost(uint64, tag = "2")]
    pub skipped_inspect: u64,
    #[prost(uint64, tag = "3")]
    pub no_connection: u64,
    #[prost(double, tag = "4")]
    pub adherence_rate: f64,
}
/// MCP usage snapshot
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct McpUsageSnapshot {
    #[prost(uint64, tag = "1")]
    pub total_calls: u64,
    #[prost(uint64, tag = "2")]
    pub total_success: u64,
    #[prost(uint64, tag = "3")]
    pub total_errors: u64,
    #[prost(double, tag = "4")]
    pub success_rate: f64,
    #[prost(double, tag = "5")]
    pub avg_latency_ms: f64,
    #[prost(message, repeated, tag = "6")]
    pub top_errors: ::prost::alloc::vec::Vec<McpErrorCount>,
    #[prost(message, optional, tag = "7")]
    pub workflow: ::core::option::Option<McpWorkflowStats>,
}
/// Information about the daemon process
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DaemonInfo {
    /// Process ID
    #[prost(uint32, tag = "1")]
    pub pid: u32,
    /// Parent process ID
    #[prost(uint32, tag = "2")]
    pub ppid: u32,
}
/// Information about a parent process that spawned an MCP client
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ParentProcessInfo {
    /// Parent process ID
    #[prost(uint32, tag = "1")]
    pub pid: u32,
    /// Name of the parent process (e.g., "windsurf", "claude", "cursor")
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// MCP bridge process ID (the direct client)
    #[prost(uint32, tag = "3")]
    pub bridge_pid: u32,
}
/// Information about a connected MCP client
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct McpClientInfo {
    /// Client identifier (UUID)
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// When the client connected (ISO 8601)
    #[prost(string, tag = "2")]
    pub connected_at: ::prost::alloc::string::String,
    /// Duration connected in seconds
    #[prost(uint64, tag = "3")]
    pub connected_duration_secs: u64,
    /// Last activity timestamp (ISO 8601)
    #[prost(string, tag = "4")]
    pub last_activity: ::prost::alloc::string::String,
    /// Seconds since last activity
    #[prost(uint64, tag = "5")]
    pub last_activity_ago_secs: u64,
    /// Parent process information (if available)
    #[prost(message, optional, tag = "6")]
    pub parent_process: ::core::option::Option<ParentProcessInfo>,
}
/// MCP error code for categorizing tool errors
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum McpErrorCode {
    Unspecified = 0,
    LocationMissingAt = 1,
    LocationMissingLine = 2,
    LocationInvalidLine = 3,
    MetricBeforeConnection = 4,
    ConnectionNotFound = 5,
    ConnectionDisconnected = 6,
    QueryMissingRequiredParam = 7,
    UnsafeExpression = 8,
    Other = 9,
}
impl McpErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MCP_ERROR_CODE_UNSPECIFIED",
            Self::LocationMissingAt => "MCP_ERROR_CODE_LOCATION_MISSING_AT",
            Self::LocationMissingLine => "MCP_ERROR_CODE_LOCATION_MISSING_LINE",
            Self::LocationInvalidLine => "MCP_ERROR_CODE_LOCATION_INVALID_LINE",
            Self::MetricBeforeConnection => "MCP_ERROR_CODE_METRIC_BEFORE_CONNECTION",
            Self::ConnectionNotFound => "MCP_ERROR_CODE_CONNECTION_NOT_FOUND",
            Self::ConnectionDisconnected => "MCP_ERROR_CODE_CONNECTION_DISCONNECTED",
            Self::QueryMissingRequiredParam => {
                "MCP_ERROR_CODE_QUERY_MISSING_REQUIRED_PARAM"
            }
            Self::UnsafeExpression => "MCP_ERROR_CODE_UNSAFE_EXPRESSION",
            Self::Other => "MCP_ERROR_CODE_OTHER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MCP_ERROR_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "MCP_ERROR_CODE_LOCATION_MISSING_AT" => Some(Self::LocationMissingAt),
            "MCP_ERROR_CODE_LOCATION_MISSING_LINE" => Some(Self::LocationMissingLine),
            "MCP_ERROR_CODE_LOCATION_INVALID_LINE" => Some(Self::LocationInvalidLine),
            "MCP_ERROR_CODE_METRIC_BEFORE_CONNECTION" => {
                Some(Self::MetricBeforeConnection)
            }
            "MCP_ERROR_CODE_CONNECTION_NOT_FOUND" => Some(Self::ConnectionNotFound),
            "MCP_ERROR_CODE_CONNECTION_DISCONNECTED" => {
                Some(Self::ConnectionDisconnected)
            }
            "MCP_ERROR_CODE_QUERY_MISSING_REQUIRED_PARAM" => {
                Some(Self::QueryMissingRequiredParam)
            }
            "MCP_ERROR_CODE_UNSAFE_EXPRESSION" => Some(Self::UnsafeExpression),
            "MCP_ERROR_CODE_OTHER" => Some(Self::Other),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WakeRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WakeResponse {
    /// "active"
    #[prost(string, tag = "1")]
    pub status: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub metrics_loaded: u32,
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SleepRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SleepResponse {
    /// "sleeping"
    #[prost(string, tag = "1")]
    pub status: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub metrics_saved: u32,
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
    /// Human-readable message (e.g., "All adapters stopped")
    #[prost(string, tag = "4")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatusRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatusResponse {
    /// Status mode: "active" if adapters connected, "idle" otherwise
    #[prost(string, tag = "1")]
    pub mode: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub enabled_metrics: u32,
    #[prost(uint64, tag = "3")]
    pub uptime_seconds: u64,
    #[prost(uint64, tag = "4")]
    pub total_events: u64,
    /// CPU usage percentage (0-100)
    #[prost(double, tag = "5")]
    pub cpu_usage_percent: f64,
    #[prost(uint64, tag = "6")]
    pub memory_usage_bytes: u64,
    #[prost(message, optional, tag = "7")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
    /// Human-readable uptime (e.g., "1d 02:30:45" or "02:30:45")
    #[prost(string, tag = "8")]
    pub uptime_formatted: ::prost::alloc::string::String,
    /// Started timestamp (ISO 8601)
    #[prost(string, tag = "9")]
    pub started_at: ::prost::alloc::string::String,
    #[prost(uint32, tag = "10")]
    pub total_metrics: u32,
    #[prost(uint32, tag = "11")]
    pub active_connections: u32,
    #[prost(uint32, tag = "12")]
    pub total_connections: u32,
    /// Whether any DAP adapter is connected
    #[prost(bool, tag = "13")]
    pub adapter_connected: bool,
    /// Daemon process info (PID, parent PID)
    #[prost(message, optional, tag = "14")]
    pub daemon: ::core::option::Option<DaemonInfo>,
    /// Connected MCP clients
    #[prost(message, repeated, tag = "15")]
    pub mcp_clients: ::prost::alloc::vec::Vec<McpClientInfo>,
    /// List of degraded components (empty if all healthy)
    #[prost(string, repeated, tag = "16")]
    pub degraded: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Path to the loaded configuration file
    #[prost(string, tag = "17")]
    pub config_path: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AddMetricRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub group: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub location: ::core::option::Option<Location>,
    #[prost(string, tag = "4")]
    pub expression: ::prost::alloc::string::String,
    /// DEPRECATED: Derived from connection if not provided
    #[prost(string, optional, tag = "5")]
    pub language: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, tag = "6")]
    #[serde(default)]
    pub enabled: bool,
    #[prost(message, optional, tag = "7")]
    pub mode: ::core::option::Option<MetricMode>,
    #[prost(string, optional, tag = "8")]
    pub condition: ::core::option::Option<::prost::alloc::string::String>,
    /// "strict", "moderate", "relaxed"
    #[prost(string, tag = "9")]
    pub safety_level: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub metadata: ::core::option::Option<RequestMetadata>,
    /// Required: ID of the connection to use for this metric
    #[prost(string, tag = "11")]
    pub connection_id: ::prost::alloc::string::String,
    /// If true, replace any existing metric at the same location (file:line).
    /// If false (default), return error when metric already exists at this location.
    /// DAP only supports one logpoint per line.
    #[prost(bool, optional, tag = "12")]
    pub replace: ::core::option::Option<bool>,
    /// Introspection options (Python-only for now)
    /// Stack trace capture
    #[prost(bool, optional, tag = "13")]
    #[serde(default)]
    pub capture_stack_trace: ::core::option::Option<bool>,
    /// TTL in seconds, null for continuous
    #[prost(uint64, optional, tag = "14")]
    pub stack_trace_ttl: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "15")]
    pub stack_trace_slice: ::core::option::Option<StackTraceSlice>,
    /// Memory snapshot capture
    #[prost(bool, optional, tag = "16")]
    #[serde(default)]
    pub capture_memory_snapshot: ::core::option::Option<bool>,
    /// "local", "global", "both"
    #[prost(string, optional, tag = "17")]
    pub snapshot_scope: ::core::option::Option<::prost::alloc::string::String>,
    /// TTL in seconds, null for continuous
    #[prost(uint64, optional, tag = "18")]
    pub snapshot_ttl: ::core::option::Option<u64>,
}
/// Stack trace capture configuration
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StackTraceSlice {
    /// Capture full stack (overrides head/tail)
    #[prost(bool, tag = "1")]
    pub full: bool,
    /// Capture first N frames
    #[prost(uint32, optional, tag = "2")]
    pub head: ::core::option::Option<u32>,
    /// Capture last N frames
    #[prost(uint32, optional, tag = "3")]
    pub tail: ::core::option::Option<u32>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MetricResponse {
    #[prost(uint64, tag = "1")]
    pub metric_id: u64,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub status: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub location: ::core::option::Option<Location>,
    #[prost(message, optional, tag = "5")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RemoveMetricRequest {
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<RequestMetadata>,
    #[prost(oneof = "remove_metric_request::Identifier", tags = "1, 2")]
    pub identifier: ::core::option::Option<remove_metric_request::Identifier>,
}
/// Nested message and enum types in `RemoveMetricRequest`.
pub mod remove_metric_request {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Identifier {
        #[prost(uint64, tag = "1")]
        MetricId(u64),
        #[prost(string, tag = "2")]
        Name(::prost::alloc::string::String),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RemoveMetricResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateMetricRequest {
    #[prost(uint64, tag = "1")]
    pub metric_id: u64,
    #[prost(string, optional, tag = "2")]
    pub expression: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    #[serde(default)]
    pub enabled: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "4")]
    pub mode: ::core::option::Option<MetricMode>,
    #[prost(string, optional, tag = "5")]
    pub condition: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetMetricRequest {
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<RequestMetadata>,
    #[prost(oneof = "get_metric_request::Identifier", tags = "1, 2")]
    pub identifier: ::core::option::Option<get_metric_request::Identifier>,
}
/// Nested message and enum types in `GetMetricRequest`.
pub mod get_metric_request {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Identifier {
        #[prost(uint64, tag = "1")]
        MetricId(u64),
        #[prost(string, tag = "2")]
        Name(::prost::alloc::string::String),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListMetricsRequest {
    #[prost(string, optional, tag = "1")]
    pub group: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "2")]
    pub enabled_only: ::core::option::Option<bool>,
    /// Wildcards supported
    #[prost(string, optional, tag = "3")]
    pub name_pattern: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMetricsResponse {
    #[prost(message, repeated, tag = "1")]
    pub metrics: ::prost::alloc::vec::Vec<MetricInfo>,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MetricInfo {
    #[prost(uint64, tag = "1")]
    pub metric_id: u64,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3")]
    pub group: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub location: ::core::option::Option<Location>,
    #[prost(string, tag = "5")]
    pub expression: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub language: ::prost::alloc::string::String,
    #[prost(bool, tag = "7")]
    #[serde(default)]
    pub enabled: bool,
    #[prost(message, optional, tag = "8")]
    pub mode: ::core::option::Option<MetricMode>,
    #[prost(int64, tag = "9")]
    pub created_at: i64,
    #[prost(uint64, tag = "10")]
    pub hit_count: u64,
    #[prost(int64, optional, tag = "11")]
    pub last_hit_at: ::core::option::Option<i64>,
    #[prost(string, tag = "12")]
    pub connection_id: ::prost::alloc::string::String,
    /// Introspection settings
    #[prost(bool, tag = "13")]
    #[serde(default)]
    pub capture_stack_trace: bool,
    #[prost(bool, tag = "14")]
    #[serde(default)]
    pub capture_memory_snapshot: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ToggleMetricRequest {
    #[prost(uint64, tag = "1")]
    pub metric_id: u64,
    #[prost(bool, tag = "2")]
    #[serde(default)]
    pub enabled: bool,
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ToggleMetricResponse {
    #[prost(uint64, tag = "1")]
    pub metric_id: u64,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    #[serde(default)]
    pub enabled: bool,
    /// Whether storage was successfully updated
    #[prost(bool, tag = "4")]
    pub storage_updated: bool,
    /// Whether DAP confirmed the operation (breakpoint set/removed)
    #[prost(bool, tag = "5")]
    pub dap_confirmed: bool,
    /// Actual line where breakpoint was set (may differ from requested)
    #[prost(uint32, optional, tag = "6")]
    pub actual_line: ::core::option::Option<u32>,
    /// Message from DAP (e.g., verification status, errors)
    #[prost(string, optional, tag = "7")]
    pub dap_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "8")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
    /// Status string for HTTP response (e.g., "enabled", "disabled")
    #[prost(string, tag = "9")]
    pub status: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupRequest {
    #[prost(string, tag = "1")]
    pub group_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupResponse {
    #[prost(string, tag = "1")]
    pub group_name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub metrics_affected: u32,
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListGroupsRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGroupsResponse {
    #[prost(message, repeated, tag = "1")]
    pub groups: ::prost::alloc::vec::Vec<GroupInfo>,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub metric_count: u32,
    #[prost(uint32, tag = "3")]
    pub enabled_count: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReloadConfigRequest {
    #[prost(string, optional, tag = "1")]
    pub config_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReloadConfigResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(uint32, tag = "2")]
    pub metrics_loaded: u32,
    #[prost(string, repeated, tag = "3")]
    pub errors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ValidateConfigRequest {
    #[prost(string, tag = "1")]
    pub config_toml: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ValidationResponse {
    #[prost(bool, tag = "1")]
    pub valid: bool,
    #[prost(string, repeated, tag = "2")]
    pub errors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetConfigRequest {
    /// Get specific config value
    #[prost(string, optional, tag = "1")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConfigResponse {
    #[prost(string, tag = "1")]
    pub config_toml: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub version: i64,
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateConfigRequest {
    #[prost(string, tag = "1")]
    pub config_toml: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub merge: bool,
    #[prost(bool, tag = "3")]
    pub persist: bool,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ValidateExpressionRequest {
    #[prost(string, tag = "1")]
    pub expression: ::prost::alloc::string::String,
    /// "python", "go", "rust" - defaults to "python"
    #[prost(string, tag = "2")]
    pub language: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<RequestMetadata>,
    /// Safety level ('strict', 'trusted'). If not provided, uses default from SafetyConfig.
    #[prost(string, optional, tag = "4")]
    pub safety_level: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ValidateExpressionResponse {
    #[prost(bool, tag = "1")]
    pub is_safe: bool,
    #[prost(string, tag = "2")]
    pub expression: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
    /// Language that was validated
    #[prost(string, tag = "5")]
    pub language: ::prost::alloc::string::String,
    /// List of violations (reasons why expression is unsafe)
    #[prost(string, repeated, tag = "6")]
    pub violations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of warnings (non-blocking issues)
    #[prost(string, repeated, tag = "7")]
    pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InspectFileRequest {
    #[prost(string, tag = "1")]
    pub file_path: ::prost::alloc::string::String,
    /// If provided, inspect specific line (1-based)
    #[prost(uint32, optional, tag = "2")]
    pub line: ::core::option::Option<u32>,
    /// If provided, search for variable occurrences
    #[prost(string, optional, tag = "3")]
    pub find_variable: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InspectFileResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    /// JSON-encoded inspection result
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetMcpUsageRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMcpUsageResponse {
    #[prost(message, optional, tag = "1")]
    pub usage: ::core::option::Option<McpUsageSnapshot>,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
/// Generated client implementations.
pub mod metrics_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct MetricsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MetricsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MetricsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MetricsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MetricsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Runtime control
        pub async fn wake(
            &mut self,
            request: impl tonic::IntoRequest<super::WakeRequest>,
        ) -> std::result::Result<tonic::Response<super::WakeResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.MetricsService/Wake",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.MetricsService", "Wake"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn sleep(
            &mut self,
            request: impl tonic::IntoRequest<super::SleepRequest>,
        ) -> std::result::Result<tonic::Response<super::SleepResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.MetricsService/Sleep",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.MetricsService", "Sleep"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_status(
            &mut self,
            request: impl tonic::IntoRequest<super::StatusRequest>,
        ) -> std::result::Result<tonic::Response<super::StatusResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.MetricsService/GetStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.MetricsService", "GetStatus"));
            self.inner.unary(req, path, codec).await
        }
        /// Metric management
        pub async fn add_metric(
            &mut self,
            request: impl tonic::IntoRequest<super::AddMetricRequest>,
        ) -> std::result::Result<tonic::Response<super::MetricResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.MetricsService/AddMetric",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.MetricsService", "AddMetric"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn remove_metric(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveMetricRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveMetricResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.MetricsService/RemoveMetric",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.MetricsService", "RemoveMetric"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_metric(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateMetricRequest>,
        ) -> std::result::Result<tonic::Response<super::MetricResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.MetricsService/UpdateMetric",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.MetricsService", "UpdateMetric"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_metric(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMetricRequest>,
        ) -> std::result::Result<tonic::Response<super::MetricResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.MetricsService/GetMetric",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.MetricsService", "GetMetric"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn list_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMetricsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.MetricsService/ListMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.MetricsService", "ListMetrics"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn toggle_metric(
            &mut self,
            request: impl tonic::IntoRequest<super::ToggleMetricRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ToggleMetricResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.MetricsService/ToggleMetric",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.MetricsService", "ToggleMetric"));
            self.inner.unary(req, path, codec).await
        }
        /// Group operations
        pub async fn enable_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GroupRequest>,
        ) -> std::result::Result<tonic::Response<super::GroupResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.MetricsService/EnableGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.MetricsService", "EnableGroup"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn disable_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GroupRequest>,
        ) -> std::result::Result<tonic::Response<super::GroupResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.MetricsService/DisableGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.MetricsService", "DisableGroup"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn list_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.MetricsService/ListGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.MetricsService", "ListGroups"));
            self.inner.unary(req, path, codec).await
        }
        /// Configuration
        pub async fn reload_config(
            &mut self,
            request: impl tonic::IntoRequest<super::ReloadConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReloadConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.MetricsService/ReloadConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.MetricsService", "ReloadConfig"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn validate_config(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.MetricsService/ValidateConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.MetricsService", "ValidateConfig"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::ConfigResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.MetricsService/GetConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.MetricsService", "GetConfig"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::ConfigResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.MetricsService/UpdateConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.MetricsService", "UpdateConfig"));
            self.inner.unary(req, path, codec).await
        }
        /// Validation and introspection
        pub async fn validate_expression(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateExpressionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateExpressionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.MetricsService/ValidateExpression",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("detrix.v1.MetricsService", "ValidateExpression"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn inspect_file(
            &mut self,
            request: impl tonic::IntoRequest<super::InspectFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InspectFileResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.MetricsService/InspectFile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.MetricsService", "InspectFile"));
            self.inner.unary(req, path, codec).await
        }
        /// MCP usage statistics
        pub async fn get_mcp_usage(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMcpUsageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetMcpUsageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.MetricsService/GetMcpUsage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.MetricsService", "GetMcpUsage"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod metrics_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with MetricsServiceServer.
    #[async_trait]
    pub trait MetricsService: std::marker::Send + std::marker::Sync + 'static {
        /// Runtime control
        async fn wake(
            &self,
            request: tonic::Request<super::WakeRequest>,
        ) -> std::result::Result<tonic::Response<super::WakeResponse>, tonic::Status>;
        async fn sleep(
            &self,
            request: tonic::Request<super::SleepRequest>,
        ) -> std::result::Result<tonic::Response<super::SleepResponse>, tonic::Status>;
        async fn get_status(
            &self,
            request: tonic::Request<super::StatusRequest>,
        ) -> std::result::Result<tonic::Response<super::StatusResponse>, tonic::Status>;
        /// Metric management
        async fn add_metric(
            &self,
            request: tonic::Request<super::AddMetricRequest>,
        ) -> std::result::Result<tonic::Response<super::MetricResponse>, tonic::Status>;
        async fn remove_metric(
            &self,
            request: tonic::Request<super::RemoveMetricRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveMetricResponse>,
            tonic::Status,
        >;
        async fn update_metric(
            &self,
            request: tonic::Request<super::UpdateMetricRequest>,
        ) -> std::result::Result<tonic::Response<super::MetricResponse>, tonic::Status>;
        async fn get_metric(
            &self,
            request: tonic::Request<super::GetMetricRequest>,
        ) -> std::result::Result<tonic::Response<super::MetricResponse>, tonic::Status>;
        async fn list_metrics(
            &self,
            request: tonic::Request<super::ListMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMetricsResponse>,
            tonic::Status,
        >;
        async fn toggle_metric(
            &self,
            request: tonic::Request<super::ToggleMetricRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ToggleMetricResponse>,
            tonic::Status,
        >;
        /// Group operations
        async fn enable_group(
            &self,
            request: tonic::Request<super::GroupRequest>,
        ) -> std::result::Result<tonic::Response<super::GroupResponse>, tonic::Status>;
        async fn disable_group(
            &self,
            request: tonic::Request<super::GroupRequest>,
        ) -> std::result::Result<tonic::Response<super::GroupResponse>, tonic::Status>;
        async fn list_groups(
            &self,
            request: tonic::Request<super::ListGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListGroupsResponse>,
            tonic::Status,
        >;
        /// Configuration
        async fn reload_config(
            &self,
            request: tonic::Request<super::ReloadConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReloadConfigResponse>,
            tonic::Status,
        >;
        async fn validate_config(
            &self,
            request: tonic::Request<super::ValidateConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidationResponse>,
            tonic::Status,
        >;
        async fn get_config(
            &self,
            request: tonic::Request<super::GetConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::ConfigResponse>, tonic::Status>;
        async fn update_config(
            &self,
            request: tonic::Request<super::UpdateConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::ConfigResponse>, tonic::Status>;
        /// Validation and introspection
        async fn validate_expression(
            &self,
            request: tonic::Request<super::ValidateExpressionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ValidateExpressionResponse>,
            tonic::Status,
        >;
        async fn inspect_file(
            &self,
            request: tonic::Request<super::InspectFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InspectFileResponse>,
            tonic::Status,
        >;
        /// MCP usage statistics
        async fn get_mcp_usage(
            &self,
            request: tonic::Request<super::GetMcpUsageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetMcpUsageResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct MetricsServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> MetricsServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for MetricsServiceServer<T>
    where
        T: MetricsService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/detrix.v1.MetricsService/Wake" => {
                    #[allow(non_camel_case_types)]
                    struct WakeSvc<T: MetricsService>(pub Arc<T>);
                    impl<
                        T: MetricsService,
                    > tonic::server::UnaryService<super::WakeRequest> for WakeSvc<T> {
                        type Response = super::WakeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WakeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetricsService>::wake(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = WakeSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.MetricsService/Sleep" => {
                    #[allow(non_camel_case_types)]
                    struct SleepSvc<T: MetricsService>(pub Arc<T>);
                    impl<
                        T: MetricsService,
                    > tonic::server::UnaryService<super::SleepRequest> for SleepSvc<T> {
                        type Response = super::SleepResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SleepRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetricsService>::sleep(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SleepSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.MetricsService/GetStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetStatusSvc<T: MetricsService>(pub Arc<T>);
                    impl<
                        T: MetricsService,
                    > tonic::server::UnaryService<super::StatusRequest>
                    for GetStatusSvc<T> {
                        type Response = super::StatusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetricsService>::get_status(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetStatusSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.MetricsService/AddMetric" => {
                    #[allow(non_camel_case_types)]
                    struct AddMetricSvc<T: MetricsService>(pub Arc<T>);
                    impl<
                        T: MetricsService,
                    > tonic::server::UnaryService<super::AddMetricRequest>
                    for AddMetricSvc<T> {
                        type Response = super::MetricResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddMetricRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetricsService>::add_metric(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddMetricSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.MetricsService/RemoveMetric" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveMetricSvc<T: MetricsService>(pub Arc<T>);
                    impl<
                        T: MetricsService,
                    > tonic::server::UnaryService<super::RemoveMetricRequest>
                    for RemoveMetricSvc<T> {
                        type Response = super::RemoveMetricResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RemoveMetricRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetricsService>::remove_metric(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemoveMetricSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.MetricsService/UpdateMetric" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateMetricSvc<T: MetricsService>(pub Arc<T>);
                    impl<
                        T: MetricsService,
                    > tonic::server::UnaryService<super::UpdateMetricRequest>
                    for UpdateMetricSvc<T> {
                        type Response = super::MetricResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateMetricRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetricsService>::update_metric(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateMetricSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.MetricsService/GetMetric" => {
                    #[allow(non_camel_case_types)]
                    struct GetMetricSvc<T: MetricsService>(pub Arc<T>);
                    impl<
                        T: MetricsService,
                    > tonic::server::UnaryService<super::GetMetricRequest>
                    for GetMetricSvc<T> {
                        type Response = super::MetricResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetMetricRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetricsService>::get_metric(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetMetricSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.MetricsService/ListMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct ListMetricsSvc<T: MetricsService>(pub Arc<T>);
                    impl<
                        T: MetricsService,
                    > tonic::server::UnaryService<super::ListMetricsRequest>
                    for ListMetricsSvc<T> {
                        type Response = super::ListMetricsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListMetricsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetricsService>::list_metrics(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListMetricsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.MetricsService/ToggleMetric" => {
                    #[allow(non_camel_case_types)]
                    struct ToggleMetricSvc<T: MetricsService>(pub Arc<T>);
                    impl<
                        T: MetricsService,
                    > tonic::server::UnaryService<super::ToggleMetricRequest>
                    for ToggleMetricSvc<T> {
                        type Response = super::ToggleMetricResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ToggleMetricRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetricsService>::toggle_metric(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ToggleMetricSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.MetricsService/EnableGroup" => {
                    #[allow(non_camel_case_types)]
                    struct EnableGroupSvc<T: MetricsService>(pub Arc<T>);
                    impl<
                        T: MetricsService,
                    > tonic::server::UnaryService<super::GroupRequest>
                    for EnableGroupSvc<T> {
                        type Response = super::GroupResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GroupRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetricsService>::enable_group(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EnableGroupSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.MetricsService/DisableGroup" => {
                    #[allow(non_camel_case_types)]
                    struct DisableGroupSvc<T: MetricsService>(pub Arc<T>);
                    impl<
                        T: MetricsService,
                    > tonic::server::UnaryService<super::GroupRequest>
                    for DisableGroupSvc<T> {
                        type Response = super::GroupResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GroupRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetricsService>::disable_group(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DisableGroupSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.MetricsService/ListGroups" => {
                    #[allow(non_camel_case_types)]
                    struct ListGroupsSvc<T: MetricsService>(pub Arc<T>);
                    impl<
                        T: MetricsService,
                    > tonic::server::UnaryService<super::ListGroupsRequest>
                    for ListGroupsSvc<T> {
                        type Response = super::ListGroupsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListGroupsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetricsService>::list_groups(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListGroupsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.MetricsService/ReloadConfig" => {
                    #[allow(non_camel_case_types)]
                    struct ReloadConfigSvc<T: MetricsService>(pub Arc<T>);
                    impl<
                        T: MetricsService,
                    > tonic::server::UnaryService<super::ReloadConfigRequest>
                    for ReloadConfigSvc<T> {
                        type Response = super::ReloadConfigResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReloadConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetricsService>::reload_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReloadConfigSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.MetricsService/ValidateConfig" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateConfigSvc<T: MetricsService>(pub Arc<T>);
                    impl<
                        T: MetricsService,
                    > tonic::server::UnaryService<super::ValidateConfigRequest>
                    for ValidateConfigSvc<T> {
                        type Response = super::ValidationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ValidateConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetricsService>::validate_config(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidateConfigSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.MetricsService/GetConfig" => {
                    #[allow(non_camel_case_types)]
                    struct GetConfigSvc<T: MetricsService>(pub Arc<T>);
                    impl<
                        T: MetricsService,
                    > tonic::server::UnaryService<super::GetConfigRequest>
                    for GetConfigSvc<T> {
                        type Response = super::ConfigResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetricsService>::get_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetConfigSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.MetricsService/UpdateConfig" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateConfigSvc<T: MetricsService>(pub Arc<T>);
                    impl<
                        T: MetricsService,
                    > tonic::server::UnaryService<super::UpdateConfigRequest>
                    for UpdateConfigSvc<T> {
                        type Response = super::ConfigResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetricsService>::update_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateConfigSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.MetricsService/ValidateExpression" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateExpressionSvc<T: MetricsService>(pub Arc<T>);
                    impl<
                        T: MetricsService,
                    > tonic::server::UnaryService<super::ValidateExpressionRequest>
                    for ValidateExpressionSvc<T> {
                        type Response = super::ValidateExpressionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ValidateExpressionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetricsService>::validate_expression(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidateExpressionSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.MetricsService/InspectFile" => {
                    #[allow(non_camel_case_types)]
                    struct InspectFileSvc<T: MetricsService>(pub Arc<T>);
                    impl<
                        T: MetricsService,
                    > tonic::server::UnaryService<super::InspectFileRequest>
                    for InspectFileSvc<T> {
                        type Response = super::InspectFileResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::InspectFileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetricsService>::inspect_file(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InspectFileSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.MetricsService/GetMcpUsage" => {
                    #[allow(non_camel_case_types)]
                    struct GetMcpUsageSvc<T: MetricsService>(pub Arc<T>);
                    impl<
                        T: MetricsService,
                    > tonic::server::UnaryService<super::GetMcpUsageRequest>
                    for GetMcpUsageSvc<T> {
                        type Response = super::GetMcpUsageResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetMcpUsageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MetricsService>::get_mcp_usage(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetMcpUsageSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for MetricsServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "detrix.v1.MetricsService";
    impl<T> tonic::server::NamedService for MetricsServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StreamRequest {
    #[prost(uint64, repeated, tag = "1")]
    pub metric_ids: ::prost::alloc::vec::Vec<u64>,
    #[prost(string, optional, tag = "2")]
    pub name_pattern: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupStreamRequest {
    #[prost(string, tag = "1")]
    pub group_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StreamAllRequest {
    #[prost(string, optional, tag = "1")]
    pub thread_filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetricEvent {
    #[prost(uint64, tag = "1")]
    pub metric_id: u64,
    #[prost(string, tag = "2")]
    pub metric_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub location: ::core::option::Option<Location>,
    #[prost(int64, tag = "4")]
    pub timestamp: i64,
    /// Thread info
    #[prost(string, optional, tag = "5")]
    pub thread_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "6")]
    pub thread_id: ::core::option::Option<i64>,
    /// Tracing
    #[prost(string, optional, tag = "7")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    /// For grouping related events
    #[prost(string, optional, tag = "8")]
    pub session_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Connection that produced this event
    #[prost(string, tag = "11")]
    pub connection_id: ::prost::alloc::string::String,
    /// Introspection data (optional)
    #[prost(message, optional, tag = "12")]
    pub stack_trace: ::core::option::Option<StackTrace>,
    #[prost(message, optional, tag = "13")]
    pub memory_snapshot: ::core::option::Option<MemorySnapshot>,
    /// Result
    #[prost(oneof = "metric_event::Result", tags = "9, 10")]
    pub result: ::core::option::Option<metric_event::Result>,
}
/// Nested message and enum types in `MetricEvent`.
pub mod metric_event {
    /// Result
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Result {
        #[prost(string, tag = "9")]
        ValueJson(::prost::alloc::string::String),
        #[prost(message, tag = "10")]
        Error(super::ErrorResult),
    }
}
/// Stack trace captured at metric evaluation
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StackTrace {
    #[prost(message, repeated, tag = "1")]
    pub frames: ::prost::alloc::vec::Vec<StackFrame>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StackFrame {
    #[prost(uint32, tag = "1")]
    pub index: u32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3")]
    pub file: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "4")]
    pub line: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "5")]
    pub module: ::core::option::Option<::prost::alloc::string::String>,
}
/// Memory snapshot (local/global variables)
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemorySnapshot {
    #[prost(message, repeated, tag = "1")]
    pub locals: ::prost::alloc::vec::Vec<Variable>,
    #[prost(message, repeated, tag = "2")]
    pub globals: ::prost::alloc::vec::Vec<Variable>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Variable {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ErrorResult {
    #[prost(bool, tag = "1")]
    pub error: bool,
    #[prost(string, tag = "2")]
    pub error_code: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub error_type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "5")]
    pub traceback: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryRequest {
    #[prost(uint64, repeated, tag = "1")]
    pub metric_ids: ::prost::alloc::vec::Vec<u64>,
    #[prost(message, optional, tag = "2")]
    pub time_range: ::core::option::Option<TimeRange>,
    /// Pagination
    ///
    /// Default: 100, Max: 1000
    #[prost(uint32, optional, tag = "3")]
    pub limit: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub offset: ::core::option::Option<u32>,
    /// Preferred over offset
    #[prost(string, optional, tag = "5")]
    pub cursor: ::core::option::Option<::prost::alloc::string::String>,
    /// "asc" or "desc"
    #[prost(string, optional, tag = "6")]
    pub order: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "7")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TimeRange {
    /// Unix timestamp (microseconds)
    #[prost(int64, tag = "1")]
    pub start: i64,
    #[prost(int64, tag = "2")]
    pub end: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResponse {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<MetricEvent>,
    #[prost(uint32, tag = "2")]
    pub total_count: u32,
    #[prost(bool, tag = "3")]
    pub has_more: bool,
    #[prost(string, optional, tag = "4")]
    pub next_cursor: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetValueRequest {
    #[prost(uint64, tag = "1")]
    pub metric_id: u64,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MetricValue {
    #[prost(uint64, tag = "1")]
    pub metric_id: u64,
    #[prost(string, tag = "2")]
    pub metric_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub value_json: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub timestamp: i64,
    #[prost(message, optional, tag = "5")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
/// Generated client implementations.
pub mod streaming_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct StreamingServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl StreamingServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> StreamingServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> StreamingServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            StreamingServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Stream metric events in real-time
        pub async fn stream_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::StreamRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::MetricEvent>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.StreamingService/StreamMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.StreamingService", "StreamMetrics"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn stream_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GroupStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::MetricEvent>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.StreamingService/StreamGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.StreamingService", "StreamGroup"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn stream_all(
            &mut self,
            request: impl tonic::IntoRequest<super::StreamAllRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::MetricEvent>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.StreamingService/StreamAll",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.StreamingService", "StreamAll"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Query historical data
        pub async fn query_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.StreamingService/QueryMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.StreamingService", "QueryMetrics"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_metric_value(
            &mut self,
            request: impl tonic::IntoRequest<super::GetValueRequest>,
        ) -> std::result::Result<tonic::Response<super::MetricValue>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.StreamingService/GetMetricValue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.StreamingService", "GetMetricValue"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod streaming_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with StreamingServiceServer.
    #[async_trait]
    pub trait StreamingService: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the StreamMetrics method.
        type StreamMetricsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::MetricEvent, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Stream metric events in real-time
        async fn stream_metrics(
            &self,
            request: tonic::Request<super::StreamRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::StreamMetricsStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the StreamGroup method.
        type StreamGroupStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::MetricEvent, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn stream_group(
            &self,
            request: tonic::Request<super::GroupStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::StreamGroupStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the StreamAll method.
        type StreamAllStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::MetricEvent, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn stream_all(
            &self,
            request: tonic::Request<super::StreamAllRequest>,
        ) -> std::result::Result<tonic::Response<Self::StreamAllStream>, tonic::Status>;
        /// Query historical data
        async fn query_metrics(
            &self,
            request: tonic::Request<super::QueryRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryResponse>, tonic::Status>;
        async fn get_metric_value(
            &self,
            request: tonic::Request<super::GetValueRequest>,
        ) -> std::result::Result<tonic::Response<super::MetricValue>, tonic::Status>;
    }
    #[derive(Debug)]
    pub struct StreamingServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> StreamingServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for StreamingServiceServer<T>
    where
        T: StreamingService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/detrix.v1.StreamingService/StreamMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct StreamMetricsSvc<T: StreamingService>(pub Arc<T>);
                    impl<
                        T: StreamingService,
                    > tonic::server::ServerStreamingService<super::StreamRequest>
                    for StreamMetricsSvc<T> {
                        type Response = super::MetricEvent;
                        type ResponseStream = T::StreamMetricsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StreamRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StreamingService>::stream_metrics(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StreamMetricsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.StreamingService/StreamGroup" => {
                    #[allow(non_camel_case_types)]
                    struct StreamGroupSvc<T: StreamingService>(pub Arc<T>);
                    impl<
                        T: StreamingService,
                    > tonic::server::ServerStreamingService<super::GroupStreamRequest>
                    for StreamGroupSvc<T> {
                        type Response = super::MetricEvent;
                        type ResponseStream = T::StreamGroupStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GroupStreamRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StreamingService>::stream_group(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StreamGroupSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.StreamingService/StreamAll" => {
                    #[allow(non_camel_case_types)]
                    struct StreamAllSvc<T: StreamingService>(pub Arc<T>);
                    impl<
                        T: StreamingService,
                    > tonic::server::ServerStreamingService<super::StreamAllRequest>
                    for StreamAllSvc<T> {
                        type Response = super::MetricEvent;
                        type ResponseStream = T::StreamAllStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StreamAllRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StreamingService>::stream_all(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StreamAllSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.StreamingService/QueryMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct QueryMetricsSvc<T: StreamingService>(pub Arc<T>);
                    impl<
                        T: StreamingService,
                    > tonic::server::UnaryService<super::QueryRequest>
                    for QueryMetricsSvc<T> {
                        type Response = super::QueryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StreamingService>::query_metrics(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryMetricsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.StreamingService/GetMetricValue" => {
                    #[allow(non_camel_case_types)]
                    struct GetMetricValueSvc<T: StreamingService>(pub Arc<T>);
                    impl<
                        T: StreamingService,
                    > tonic::server::UnaryService<super::GetValueRequest>
                    for GetMetricValueSvc<T> {
                        type Response = super::MetricValue;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetValueRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StreamingService>::get_metric_value(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetMetricValueSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for StreamingServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "detrix.v1.StreamingService";
    impl<T> tonic::server::NamedService for StreamingServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateConnectionRequest {
    /// Host address (e.g., "127.0.0.1", "localhost")
    #[prost(string, tag = "1")]
    pub host: ::prost::alloc::string::String,
    /// Port number (must be >= 1024)
    #[prost(uint32, tag = "2")]
    pub port: u32,
    /// Language/adapter type (e.g., "python", "go", "rust")
    #[prost(string, tag = "3")]
    pub language: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<RequestMetadata>,
    /// Program path for launch mode (Rust direct lldb-dap)
    #[prost(string, optional, tag = "5")]
    pub program: ::core::option::Option<::prost::alloc::string::String>,
    /// SafeMode: only allow logpoints, disable breakpoint-based operations
    #[prost(bool, tag = "6")]
    #[serde(default)]
    pub safe_mode: bool,
    /// Process ID for AttachPid mode (Rust client library)
    #[prost(uint32, optional, tag = "7")]
    pub pid: ::core::option::Option<u32>,
    /// Identity fields for UUID generation
    ///
    /// User-friendly name (e.g., "trade-bot")
    #[prost(string, tag = "8")]
    pub name: ::prost::alloc::string::String,
    /// Workspace directory for isolation
    #[prost(string, tag = "9")]
    pub workspace_root: ::prost::alloc::string::String,
    /// Machine hostname for multi-host support
    #[prost(string, tag = "10")]
    pub hostname: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateConnectionResponse {
    /// Stable UUID: SHA256(name|language|workspace_root|hostname)\[0..16\]
    #[prost(string, tag = "1")]
    pub connection_id: ::prost::alloc::string::String,
    /// "created", "connected", etc.
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
    /// Full connection info
    #[prost(message, optional, tag = "3")]
    pub connection: ::core::option::Option<ConnectionInfo>,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CloseConnectionRequest {
    #[prost(string, tag = "1")]
    pub connection_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CloseConnectionResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetConnectionRequest {
    #[prost(string, tag = "1")]
    pub connection_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionResponse {
    #[prost(message, optional, tag = "1")]
    pub connection: ::core::option::Option<ConnectionInfo>,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListConnectionsRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListActiveConnectionsRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConnectionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub connections: ::prost::alloc::vec::Vec<ConnectionInfo>,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CleanupConnectionsRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<RequestMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CleanupConnectionsResponse {
    /// Number of connections deleted
    #[prost(uint64, tag = "1")]
    pub deleted: u64,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionInfo {
    /// Stable UUID: SHA256(name|language|workspace_root|hostname)\[0..16\]
    #[prost(string, tag = "1")]
    pub connection_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub host: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub port: u32,
    #[prost(string, tag = "4")]
    pub language: ::prost::alloc::string::String,
    #[prost(enumeration = "ConnectionStatus", tag = "5")]
    pub status: i32,
    /// Unix timestamp (microseconds)
    #[prost(int64, tag = "6")]
    pub created_at: i64,
    /// Unix timestamp (microseconds)
    #[prost(int64, optional, tag = "7")]
    pub connected_at: ::core::option::Option<i64>,
    /// Unix timestamp (microseconds)
    #[prost(int64, optional, tag = "8")]
    pub last_active_at: ::core::option::Option<i64>,
    #[prost(bool, tag = "9")]
    #[serde(default)]
    pub auto_reconnect: bool,
    #[prost(uint32, tag = "10")]
    pub reconnect_attempts: u32,
    #[prost(uint32, tag = "11")]
    pub max_reconnect_attempts: u32,
    /// SafeMode: only allow logpoints, disable breakpoint-based operations
    #[prost(bool, tag = "12")]
    #[serde(default)]
    pub safe_mode: bool,
    /// Identity fields for UUID generation
    ///
    /// User-friendly name (e.g., "trade-bot")
    #[prost(string, optional, tag = "13")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Workspace directory for isolation
    #[prost(string, tag = "14")]
    pub workspace_root: ::prost::alloc::string::String,
    /// Machine hostname for multi-host support
    #[prost(string, tag = "15")]
    pub hostname: ::prost::alloc::string::String,
}
/// Connection status enum
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConnectionStatus {
    Unspecified = 0,
    Disconnected = 1,
    Connecting = 2,
    Connected = 3,
    Failed = 4,
}
impl ConnectionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CONNECTION_STATUS_UNSPECIFIED",
            Self::Disconnected => "CONNECTION_STATUS_DISCONNECTED",
            Self::Connecting => "CONNECTION_STATUS_CONNECTING",
            Self::Connected => "CONNECTION_STATUS_CONNECTED",
            Self::Failed => "CONNECTION_STATUS_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONNECTION_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "CONNECTION_STATUS_DISCONNECTED" => Some(Self::Disconnected),
            "CONNECTION_STATUS_CONNECTING" => Some(Self::Connecting),
            "CONNECTION_STATUS_CONNECTED" => Some(Self::Connected),
            "CONNECTION_STATUS_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod connection_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct ConnectionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ConnectionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ConnectionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ConnectionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ConnectionServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a new connection to a debugpy server
        pub async fn create_connection(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateConnectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateConnectionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.ConnectionService/CreateConnection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("detrix.v1.ConnectionService", "CreateConnection"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Disconnect from a debugpy server
        pub async fn close_connection(
            &mut self,
            request: impl tonic::IntoRequest<super::CloseConnectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CloseConnectionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.ConnectionService/CloseConnection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("detrix.v1.ConnectionService", "CloseConnection"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get connection by ID
        pub async fn get_connection(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConnectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConnectionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.ConnectionService/GetConnection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("detrix.v1.ConnectionService", "GetConnection"));
            self.inner.unary(req, path, codec).await
        }
        /// List all connections
        pub async fn list_connections(
            &mut self,
            request: impl tonic::IntoRequest<super::ListConnectionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListConnectionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.ConnectionService/ListConnections",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("detrix.v1.ConnectionService", "ListConnections"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List only active connections
        pub async fn list_active_connections(
            &mut self,
            request: impl tonic::IntoRequest<super::ListActiveConnectionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListConnectionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.ConnectionService/ListActiveConnections",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "detrix.v1.ConnectionService",
                        "ListActiveConnections",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Cleanup stale (disconnected/failed) connections
        pub async fn cleanup_connections(
            &mut self,
            request: impl tonic::IntoRequest<super::CleanupConnectionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CleanupConnectionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/detrix.v1.ConnectionService/CleanupConnections",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("detrix.v1.ConnectionService", "CleanupConnections"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod connection_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ConnectionServiceServer.
    #[async_trait]
    pub trait ConnectionService: std::marker::Send + std::marker::Sync + 'static {
        /// Create a new connection to a debugpy server
        async fn create_connection(
            &self,
            request: tonic::Request<super::CreateConnectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateConnectionResponse>,
            tonic::Status,
        >;
        /// Disconnect from a debugpy server
        async fn close_connection(
            &self,
            request: tonic::Request<super::CloseConnectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CloseConnectionResponse>,
            tonic::Status,
        >;
        /// Get connection by ID
        async fn get_connection(
            &self,
            request: tonic::Request<super::GetConnectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConnectionResponse>,
            tonic::Status,
        >;
        /// List all connections
        async fn list_connections(
            &self,
            request: tonic::Request<super::ListConnectionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListConnectionsResponse>,
            tonic::Status,
        >;
        /// List only active connections
        async fn list_active_connections(
            &self,
            request: tonic::Request<super::ListActiveConnectionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListConnectionsResponse>,
            tonic::Status,
        >;
        /// Cleanup stale (disconnected/failed) connections
        async fn cleanup_connections(
            &self,
            request: tonic::Request<super::CleanupConnectionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CleanupConnectionsResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct ConnectionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ConnectionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ConnectionServiceServer<T>
    where
        T: ConnectionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/detrix.v1.ConnectionService/CreateConnection" => {
                    #[allow(non_camel_case_types)]
                    struct CreateConnectionSvc<T: ConnectionService>(pub Arc<T>);
                    impl<
                        T: ConnectionService,
                    > tonic::server::UnaryService<super::CreateConnectionRequest>
                    for CreateConnectionSvc<T> {
                        type Response = super::CreateConnectionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateConnectionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ConnectionService>::create_connection(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateConnectionSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.ConnectionService/CloseConnection" => {
                    #[allow(non_camel_case_types)]
                    struct CloseConnectionSvc<T: ConnectionService>(pub Arc<T>);
                    impl<
                        T: ConnectionService,
                    > tonic::server::UnaryService<super::CloseConnectionRequest>
                    for CloseConnectionSvc<T> {
                        type Response = super::CloseConnectionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CloseConnectionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ConnectionService>::close_connection(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CloseConnectionSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.ConnectionService/GetConnection" => {
                    #[allow(non_camel_case_types)]
                    struct GetConnectionSvc<T: ConnectionService>(pub Arc<T>);
                    impl<
                        T: ConnectionService,
                    > tonic::server::UnaryService<super::GetConnectionRequest>
                    for GetConnectionSvc<T> {
                        type Response = super::ConnectionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetConnectionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ConnectionService>::get_connection(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetConnectionSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.ConnectionService/ListConnections" => {
                    #[allow(non_camel_case_types)]
                    struct ListConnectionsSvc<T: ConnectionService>(pub Arc<T>);
                    impl<
                        T: ConnectionService,
                    > tonic::server::UnaryService<super::ListConnectionsRequest>
                    for ListConnectionsSvc<T> {
                        type Response = super::ListConnectionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListConnectionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ConnectionService>::list_connections(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListConnectionsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.ConnectionService/ListActiveConnections" => {
                    #[allow(non_camel_case_types)]
                    struct ListActiveConnectionsSvc<T: ConnectionService>(pub Arc<T>);
                    impl<
                        T: ConnectionService,
                    > tonic::server::UnaryService<super::ListActiveConnectionsRequest>
                    for ListActiveConnectionsSvc<T> {
                        type Response = super::ListConnectionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListActiveConnectionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ConnectionService>::list_active_connections(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListActiveConnectionsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/detrix.v1.ConnectionService/CleanupConnections" => {
                    #[allow(non_camel_case_types)]
                    struct CleanupConnectionsSvc<T: ConnectionService>(pub Arc<T>);
                    impl<
                        T: ConnectionService,
                    > tonic::server::UnaryService<super::CleanupConnectionsRequest>
                    for CleanupConnectionsSvc<T> {
                        type Response = super::CleanupConnectionsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CleanupConnectionsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ConnectionService>::cleanup_connections(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CleanupConnectionsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ConnectionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "detrix.v1.ConnectionService";
    impl<T> tonic::server::NamedService for ConnectionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
