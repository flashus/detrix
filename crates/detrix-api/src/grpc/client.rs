//! Shared gRPC client utilities
//!
//! Provides authentication helpers and daemon connection utilities for gRPC clients.
//! Used by detrix-cli and detrix-tui.
//!
//! ## Usage
//!
//! ```ignore
//! use detrix_api::grpc::{DaemonEndpoints, connect_to_daemon_grpc};
//!
//! // Discover daemon endpoints with pre-loaded config
//! let endpoints = DaemonEndpoints::discover_with_config(None, Some(&config.api), Some(&config.daemon.pid_file));
//!
//! // Connect to gRPC with authentication
//! let channel = connect_to_daemon_grpc(&endpoints).await?;
//! ```

use detrix_config::constants::{
    DEFAULT_API_HOST, DEFAULT_GRPC_PORT, DEFAULT_PORT_PROBE_TIMEOUT_MS, DEFAULT_REST_PORT,
    ENV_DETRIX_GRPC_PORT, ENV_DETRIX_GRPC_PORT_OVERRIDE, ENV_DETRIX_HTTP_PORT, ENV_DETRIX_TOKEN,
};
use detrix_config::paths::{default_pid_path, mcp_token_path};
use detrix_config::pid::PidInfo;
use detrix_config::{ApiConfig, ServiceType};
use std::net::TcpStream;
use std::path::Path;
use std::time::Duration;
use tonic::service::interceptor::InterceptedService;
use tonic::transport::Channel;
use tonic::{Request, Status};
use tracing::debug;

use super::auth::{AUTHORIZATION_METADATA_KEY, BEARER_PREFIX};

/// Type alias for authenticated gRPC channel
pub type AuthChannel = InterceptedService<Channel, AuthInterceptor>;

/// Auth interceptor that adds bearer token to all requests
#[derive(Clone)]
pub struct AuthInterceptor {
    token: Option<String>,
}

impl AuthInterceptor {
    /// Create a new auth interceptor with optional token
    pub fn new(token: Option<String>) -> Self {
        Self { token }
    }
}

impl tonic::service::Interceptor for AuthInterceptor {
    fn call(&mut self, mut request: Request<()>) -> Result<Request<()>, Status> {
        if let Some(ref token) = self.token {
            let auth_value = format!("{}{}", BEARER_PREFIX, token);
            let header_value = auth_value.parse().map_err(|e| {
                Status::invalid_argument(format!("Invalid auth header value: {}", e))
            })?;
            request
                .metadata_mut()
                .insert(AUTHORIZATION_METADATA_KEY, header_value);
        }
        Ok(request)
    }
}

/// Discover auth token for daemon communication
///
/// Token is discovered in priority order:
/// 1. DETRIX_TOKEN environment variable
/// 2. Token file at ~/detrix/mcp-token (auto-generated by daemon)
///
/// Returns None if no token is found (auth may be disabled).
pub fn read_auth_token() -> Option<String> {
    // 1. Check environment variable (highest priority)
    if let Ok(token) = std::env::var(ENV_DETRIX_TOKEN) {
        if !token.is_empty() {
            debug!("Using auth token from DETRIX_TOKEN env var");
            return Some(token);
        }
    }

    // 2. Check well-known token file (auto-generated by daemon)
    let token_path = mcp_token_path();
    if let Ok(token) = std::fs::read_to_string(&token_path) {
        let token = token.trim().to_string();
        if !token.is_empty() {
            debug!("Using auth token from {}", token_path.display());
            return Some(token);
        }
    }

    None
}

/// Build gRPC endpoint URL for given host and port
pub fn build_grpc_endpoint(host: &str, port: u16) -> String {
    format!("http://{}:{}", host, port)
}

/// How the daemon endpoints were discovered
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EndpointDiscoveryMethod {
    /// Discovered from PID file
    PidFile,
    /// Discovered via port probing (PID file was stale or missing)
    PortProbe,
    /// Using environment variables
    EnvVar,
    /// Using config values or hardcoded defaults
    ConfigOrDefault,
}

/// Discovered daemon endpoints
///
/// Contains host and port information for connecting to the Detrix daemon.
/// Endpoints are discovered from PID file, environment variables, port probing, or defaults.
#[derive(Debug, Clone)]
pub struct DaemonEndpoints {
    /// Host the daemon is listening on (e.g., "127.0.0.1")
    pub host: String,
    /// gRPC port (see DEFAULT_GRPC_PORT)
    pub grpc_port: u16,
    /// HTTP/REST port (see DEFAULT_REST_PORT)
    pub http_port: u16,
    /// Whether endpoints were discovered from PID file
    pub from_pid_file: bool,
    /// How the endpoints were discovered
    pub discovery_method: EndpointDiscoveryMethod,
}

impl DaemonEndpoints {
    /// Discover daemon endpoints with pre-loaded config
    ///
    /// Use this when you already have a loaded config (e.g., from ClientContext).
    /// This avoids duplicate config loading.
    ///
    /// Resolution order:
    /// 1. Explicit port overrides (if provided)
    /// 2. Environment variables (DETRIX_GRPC_PORT_OVERRIDE, DETRIX_GRPC_PORT, DETRIX_HTTP_PORT)
    /// 3. PID file (custom path from config, or default ~/detrix/daemon.pid)
    /// 4. Pre-loaded config values (if provided)
    /// 5. Hardcoded defaults
    ///
    /// # Arguments
    /// * `grpc_port_override` - Optional explicit gRPC port override
    /// * `api_config` - Optional pre-loaded API config (used as fallback)
    /// * `pid_path` - Optional custom PID file path from config (uses default if None)
    pub fn discover_with_config(
        grpc_port_override: Option<u16>,
        api_config: Option<&ApiConfig>,
        pid_path: Option<&Path>,
    ) -> Self {
        let effective_pid_path = pid_path
            .map(|p| p.to_path_buf())
            .unwrap_or_else(default_pid_path);
        Self::discover_internal(grpc_port_override, &effective_pid_path, api_config)
    }

    /// Internal discovery logic - does not load config
    fn discover_internal(
        grpc_port_override: Option<u16>,
        pid_path: &Path,
        api_config: Option<&ApiConfig>,
    ) -> Self {
        // Get config values or use hardcoded defaults
        let defaults = ApiConfig::default();
        let config_api = api_config.unwrap_or(&defaults);
        let config_source = if api_config.is_some() {
            "config"
        } else {
            "hardcoded default"
        };

        let config_host = config_api.grpc.host.clone();
        let config_grpc_port = config_api.grpc.port;
        let config_http_port = config_api.rest.port;

        // Check for env var overrides
        let grpc_port_env_override = std::env::var(ENV_DETRIX_GRPC_PORT_OVERRIDE)
            .ok()
            .and_then(|s| s.parse().ok());
        let grpc_port_env = std::env::var(ENV_DETRIX_GRPC_PORT)
            .ok()
            .and_then(|s| s.parse().ok());
        let http_port_env = std::env::var(ENV_DETRIX_HTTP_PORT)
            .ok()
            .and_then(|s| s.parse().ok());

        // Try to read PID file with detailed logging
        let pid_info = match PidInfo::read_from_file(pid_path) {
            Ok(Some(info)) => {
                debug!(
                    pid_file = %pid_path.display(),
                    pid = info.pid,
                    host = %info.host,
                    grpc_port = ?info.get_port(ServiceType::Grpc),
                    http_port = ?info.get_port(ServiceType::Http),
                    "Discovered daemon from PID file"
                );
                Some(info)
            }
            Ok(None) => {
                debug!(
                    pid_file = %pid_path.display(),
                    "PID file does not exist, will try port probe"
                );
                None
            }
            Err(e) => {
                debug!(
                    pid_file = %pid_path.display(),
                    error = %e,
                    "Failed to read PID file, will try port probe"
                );
                None
            }
        };

        // Determine final values with source tracking
        let from_pid_file =
            pid_info.is_some() && grpc_port_override.is_none() && grpc_port_env_override.is_none();

        // Track discovery method
        let mut discovery_method = if from_pid_file {
            EndpointDiscoveryMethod::PidFile
        } else if grpc_port_env_override.is_some() || grpc_port_env.is_some() {
            EndpointDiscoveryMethod::EnvVar
        } else {
            EndpointDiscoveryMethod::ConfigOrDefault
        };

        // If no PID file and no env overrides, try port probing as fallback
        // Use config ports first, then fall back to hardcoded defaults
        let port_probe_result = if pid_info.is_none()
            && grpc_port_override.is_none()
            && grpc_port_env_override.is_none()
            && grpc_port_env.is_none()
        {
            Self::probe_ports(&config_host, config_grpc_port, config_http_port)
        } else {
            None
        };

        if port_probe_result.is_some() {
            discovery_method = EndpointDiscoveryMethod::PortProbe;
        }

        // Determine host (from PID file, port probe, or config/default)
        let (host, host_source) = if let Some(ref info) = pid_info {
            (info.host.clone(), "PID file")
        } else if port_probe_result.is_some() {
            (config_host.clone(), "port probe")
        } else {
            (config_host, config_source)
        };

        // Determine gRPC port with source tracking
        // Priority: explicit override > env override > PID file > port probe (confirms service running) > env var > config/default
        // Note: port probe uses default ports but confirms something is actually listening there
        let (grpc_port, grpc_source) = if let Some(port) = grpc_port_override {
            (port, "explicit override")
        } else if let Some(port) = grpc_port_env_override {
            (port, "DETRIX_GRPC_PORT_OVERRIDE env var")
        } else if let Some(port) = pid_info
            .as_ref()
            .and_then(|i| i.get_port(ServiceType::Grpc))
        {
            (port, "PID file")
        } else if let Some((grpc, _)) = port_probe_result {
            (grpc, "port probe")
        } else if let Some(port) = grpc_port_env {
            (port, "DETRIX_GRPC_PORT env var")
        } else {
            (config_grpc_port, config_source)
        };

        // Determine HTTP port with source tracking
        // Priority: env var > PID file > port probe (confirms service running on defaults) > config/default
        let (http_port, http_source) = if let Some(port) = http_port_env {
            (port, "DETRIX_HTTP_PORT env var")
        } else if let Some(port) = pid_info
            .as_ref()
            .and_then(|i| i.get_port(ServiceType::Http))
        {
            (port, "PID file")
        } else if let Some((_, http)) = port_probe_result {
            (http, "port probe")
        } else {
            (config_http_port, config_source)
        };

        debug!(
            host = %host,
            host_source = host_source,
            grpc_port = grpc_port,
            grpc_source = grpc_source,
            http_port = http_port,
            http_source = http_source,
            discovery_method = ?discovery_method,
            "Endpoint discovery complete"
        );

        Self {
            host,
            grpc_port,
            http_port,
            from_pid_file,
            discovery_method,
        }
    }

    /// Probe ports to check if daemon is running
    ///
    /// Tries config ports first, then falls back to hardcoded defaults if different.
    /// Returns (grpc_port, http_port) if daemon is found.
    fn probe_ports(host: &str, config_grpc: u16, config_http: u16) -> Option<(u16, u16)> {
        let timeout = Duration::from_millis(DEFAULT_PORT_PROBE_TIMEOUT_MS);

        // Try config ports first (primary attempt)
        let grpc_addr = format!("{}:{}", host, config_grpc);
        if Self::is_port_open(&grpc_addr, timeout) {
            let http_addr = format!("{}:{}", host, config_http);
            if Self::is_port_open(&http_addr, timeout) {
                debug!(
                    "Daemon found via port probe on {}:{} and {}:{}",
                    host, config_grpc, host, config_http
                );
                return Some((config_grpc, config_http));
            }
            // Only gRPC port is open - assume config HTTP port
            debug!(
                "Daemon found via port probe on {}:{} (HTTP port assumed)",
                host, config_grpc
            );
            return Some((config_grpc, config_http));
        }

        // Try HTTP port alone with config value
        let http_addr = format!("{}:{}", host, config_http);
        if Self::is_port_open(&http_addr, timeout) {
            debug!(
                "Daemon found via port probe on {}:{} (gRPC port assumed)",
                host, config_http
            );
            return Some((config_grpc, config_http));
        }

        // If config ports differ from defaults, also try hardcoded defaults as fallback
        if config_grpc != DEFAULT_GRPC_PORT || config_http != DEFAULT_REST_PORT {
            let grpc_addr = format!("{}:{}", host, DEFAULT_GRPC_PORT);
            if Self::is_port_open(&grpc_addr, timeout) {
                let http_addr = format!("{}:{}", host, DEFAULT_REST_PORT);
                if Self::is_port_open(&http_addr, timeout) {
                    debug!(
                        "Daemon found via port probe on default ports {}:{} and {}:{}",
                        host, DEFAULT_GRPC_PORT, host, DEFAULT_REST_PORT
                    );
                    return Some((DEFAULT_GRPC_PORT, DEFAULT_REST_PORT));
                }
                debug!(
                    "Daemon found via port probe on default gRPC port {}:{}",
                    host, DEFAULT_GRPC_PORT
                );
                return Some((DEFAULT_GRPC_PORT, DEFAULT_REST_PORT));
            }
        }

        // Also try default API host if different from config host
        if host != DEFAULT_API_HOST {
            let grpc_addr = format!("{}:{}", DEFAULT_API_HOST, config_grpc);
            if Self::is_port_open(&grpc_addr, timeout) {
                debug!(
                    "Daemon found via port probe on {}:{} (fallback host)",
                    DEFAULT_API_HOST, config_grpc
                );
                return Some((config_grpc, config_http));
            }
        }

        debug!("Port probe: no daemon found");
        None
    }

    /// Check if a port is open by attempting a TCP connection
    fn is_port_open(addr: &str, timeout: Duration) -> bool {
        TcpStream::connect_timeout(
            &addr.parse().unwrap_or_else(|_| {
                format!("127.0.0.1:{}", DEFAULT_GRPC_PORT)
                    .parse()
                    .expect("default address should parse")
            }),
            timeout,
        )
        .is_ok()
    }

    /// Get the gRPC endpoint URL (e.g., "http://127.0.0.1:50051")
    pub fn grpc_endpoint(&self) -> String {
        build_grpc_endpoint(&self.host, self.grpc_port)
    }

    /// Get the HTTP endpoint URL (e.g., "http://127.0.0.1:8080")
    pub fn http_endpoint(&self) -> String {
        format!("http://{}:{}", self.host, self.http_port)
    }
}

/// Connect to daemon gRPC endpoint with authentication
///
/// Creates an authenticated gRPC channel using discovered endpoints.
///
/// # Errors
/// Returns error if connection fails. The error message includes whether
/// a PID file was found to help diagnose issues.
pub async fn connect_to_daemon_grpc(
    endpoints: &DaemonEndpoints,
) -> Result<AuthChannel, DaemonConnectionError> {
    let endpoint_url = endpoints.grpc_endpoint();

    let channel = Channel::from_shared(endpoint_url.clone())
        .map_err(|e| DaemonConnectionError::InvalidEndpoint {
            endpoint: endpoint_url.clone(),
            reason: e.to_string(),
        })?
        .connect()
        .await
        .map_err(|e| DaemonConnectionError::ConnectionFailed {
            endpoint: endpoint_url,
            from_pid_file: endpoints.from_pid_file,
            reason: e.to_string(),
        })?;

    let token = read_auth_token();
    let interceptor = AuthInterceptor::new(token);

    Ok(InterceptedService::new(channel, interceptor))
}

/// Error type for daemon connection failures
#[derive(Debug, thiserror::Error)]
pub enum DaemonConnectionError {
    #[error("Invalid gRPC endpoint '{endpoint}': {reason}")]
    InvalidEndpoint { endpoint: String, reason: String },

    #[error(
        "Failed to connect to Detrix daemon at {endpoint}{}. Is the daemon running? \
         Start with 'detrix daemon start'{}",
        if *from_pid_file { "" } else { " (PID file not found, tried default port)" },
        if *from_pid_file { "" } else { " or set DETRIX_GRPC_PORT env var" }
    )]
    ConnectionFailed {
        endpoint: String,
        from_pid_file: bool,
        #[allow(dead_code)]
        reason: String,
    },
}

#[cfg(test)]
mod tests {
    use super::*;
    use tonic::service::Interceptor;

    #[test]
    fn test_auth_interceptor_with_token() {
        let mut interceptor = AuthInterceptor::new(Some("test-token".to_string()));
        let request = Request::new(());
        let result = interceptor.call(request);
        assert!(result.is_ok());

        let req = result.unwrap();
        let auth = req.metadata().get(AUTHORIZATION_METADATA_KEY).unwrap();
        assert_eq!(
            auth.to_str().unwrap(),
            format!("{}test-token", BEARER_PREFIX)
        );
    }

    #[test]
    fn test_auth_interceptor_without_token() {
        let mut interceptor = AuthInterceptor::new(None);
        let request = Request::new(());
        let result = interceptor.call(request);
        assert!(result.is_ok());

        let req = result.unwrap();
        assert!(req.metadata().get(AUTHORIZATION_METADATA_KEY).is_none());
    }

    #[test]
    fn test_build_grpc_endpoint() {
        assert_eq!(
            build_grpc_endpoint("127.0.0.1", 50051),
            "http://127.0.0.1:50051"
        );
        assert_eq!(
            build_grpc_endpoint("192.168.1.100", 8080),
            "http://192.168.1.100:8080"
        );
        assert_eq!(build_grpc_endpoint("0.0.0.0", 9000), "http://0.0.0.0:9000");
    }
}
